!JSON for Modern C++https://github.com/nlohmann/json/releases !Build Statushttps://ci.appveyor.com/project/nlohmann/json !Ubuntuhttps://github.com/nlohmann/json/actions?query=workflow%3AUbuntu !macOShttps://github.com/nlohmann/json/actions?query=workflow%3AmacOS !Windowshttps://github.com/nlohmann/json/actions?query=workflow%3AWindows !Coverage Statushttps://coveralls.io/github/nlohmann/json?branch=develop !Coverity Scan Build Statushttps://scan.coverity.com/projects/nlohmann-json !Codacy Badgehttps://app.codacy.com/gh/nlohmann/json/dashboard?utmsource=gh&utmmedium=referral&utmcontent=&utmcampaign=Badgegrade !Cirrus CIhttps://cirrus-ci.com/github/nlohmann/json !Fuzzing Statushttps://bugs.chromium.org/p/oss-fuzz/issues/list?sort=-opened&can=1&q=proj:json !Try onlinehttps://wandbox.org/permlink/1mp10JbaANo6FUc7 !Documentationhttps://json.nlohmann.me !GitHub licensehttps://raw.githubusercontent.com/nlohmann/json/master/LICENSE.MIT !GitHub Releaseshttps://github.com/nlohmann/json/releases !Packaging statushttps://repology.org/project/nlohmann-json/versions !GitHub Downloadshttps://github.com/nlohmann/json/releases !GitHub Issueshttps://github.com/nlohmann/json/issues !Average time to resolve an issuehttps://isitmaintained.com/project/nlohmann/json "Average time to resolve an issue" !CII Best Practiceshttps://bestpractices.coreinfrastructure.org/projects/289 !OpenSSF Scorecardhttps://scorecard.dev/viewer/?uri=github.com/nlohmann/json !Backup Statushttps://cloudback.it !GitHub Sponsorshttps://github.com/sponsors/nlohmann !REUSE statushttps://api.reuse.software/info/github.com/nlohmann/json !Discordhttps://discord.gg/6mrGXKvX7y - Design goals - Sponsors - Support documentation, FAQ, discussions, API, bug issues - Quick reference - Examples - Read JSON from a file - Creating objects from JSON literals - JSON as a first-class data type - Serialization / Deserialization - STL-like access - Conversion from STL containers - JSON Pointer and JSON Patch - JSON Merge Patch - Implicit conversions - Conversions to/from arbitrary types - Specializing enum conversion - Binary formats BSON, CBOR, MessagePack, UBJSON, and BJData - Customers - Supported compilers - Integration - CMake - Package Managers - Pkg-config - License - Contact - Thanks - Used third-party tools - Notes - Execute unit tests Design goals There are myriads of JSON libraries out there, and each may even have its reason to exist. Our class had these design goals: - Intuitive syntax. In languages such as Python, JSON feels like a first-class data type. We used all the operator magic of modern C++ to achieve the same feeling in your code. Check out the examples below and you'll know what I mean. - Trivial integration. Our whole code consists of a single header file https://github.com/nlohmann/json/blob/develop/singleinclude/nlohmann/json.hpp. That's it. No library, no subproject, no dependencies, no complex build system. The class is written in vanilla C++11. All in all, everything should require no adjustment of your compiler flags or project settings. The library is also included in all popular package managers. - Serious testing. Our code is heavily unit-tested and covers 100% of the code, including all exceptional behavior. Furthermore, we checked with Valgrind and the Clang Sanitizers that there are no memory leaks. Google OSS-Fuzz additionally runs fuzz tests against all parsers 24/7, effectively executing billions of tests so far. To maintain high quality, the project is following the Core Infrastructure Initiative CII best practices. See the quality assurance overview documentation. Other aspects were not so important to us: - Memory efficiency. Each JSON object has an overhead of one pointer the maximal size of a union and one enumeration element 1 byte. The default generalization uses the following C++ data types: for strings, , or for numbers, for objects, for arrays, and for Booleans. However, you can template the generalized class to your needs. - Speed. There are certainly faster JSON libraries out there. However, if your goal is to speed up your development by adding JSON support with a single header, then this library is the way to go. If you know how to use a or , you are already set. See the contribution guidelines for more information. Sponsors You can sponsor this library at GitHub Sponsors. :raisinghand: Priority Sponsor - Martti Laine - Paul Harrington :label: Named Sponsors - Michael Hartmann - Stefan Hagen - Steve Sperandeo - Robert Jefe Lindstädt - Steve Wagner - Lion Yang Further support The development of the library is further supported by JetBrains by providing free access to their IDE tools. !JetBrains logo.https://jb.gg/OpenSourceSupport Thanks everyone! Support :question: If you have a question, please check if it is already answered in the FAQ or the Q&A section. If not, please ask a new question there. :books: If you want to learn more about how to use the library, check out the rest of the README, have a look at code examples, or browse through the help pages. :construction: If you want to understand the API better, check out the API Reference or have a look at the quick reference below. :bug: If you found a bug, please check the FAQ if it is a known issue or the result of a design decision. Please also have a look at the issue list before you create a new issue. Please provide as much information as possible to help us understand and reproduce your issue. There is also a docset for the documentation browsers Dash, Velocity, and Zeal that contains the full documentation as an offline resource. Quick reference - Constructors basicjson, array, binary, object - Object inspection: type, operator valuet, typename, isprimitive, isstructured, isnull, isboolean, isnumber, isnumberinteger, isnumberunsigned, isnumberfloat, isobject, isarray, isstring, isbinary, isdiscarded - Value access; get, getto, getptr, getref, operator ValueType, getbinary - Element access: at, operatorhttps://json.nlohmann.me/api/basicjson/operator, value, front, back - Lookup: find, count, contains - Iterators: begin, cbegin, end, cend, rbegin, rend, crbegin, crend, items - Capacity: empty, size, maxsize - Modifiers: clear, pushback, operator+=, emplaceback, emplace, erase, insert, update, swap - Lexicographical comparison operators: operator==, operator!=, operator<, operator>, operator<=, operator>=, operator<=> - Serialization / Dumping: dump - Deserialization / Parsing: parse, accept, saxparse - JSON Pointer functions: flatten, unflatten - JSON Patch functions: patch, patchinplace, diff, mergepatch - Static functions: meta, getallocator - Binary formats: frombjdata, frombson, fromcbor, frommsgpack, fromubjson, tobjdata, tobson, tocbor, tomsgpack, toubjson - Non-member functions: operator<<, operator>>, tostring - Literals: operator""json - Helper classes: std::hash&lt;basicjson&gt;, std::swap&lt;basicjson&gt; Full API documentation Examples Here are some examples to give you an idea how to use the class. Besides the examples below, you may want to: → Check the documentation\ → Browse the standalone example files\ → Read the full API Documentation with self-contained examples for every function Read JSON from a file The class provides an API for manipulating a JSON value. To create a object by reading a JSON file: If using modules enabled with , this example becomes: Creating objects from JSON literals Assume you want to create hard-code this literal JSON value in a file, as a object: There are various options: JSON as a first-class data type Here are some examples to give you an idea how to use the class. Assume you want to create the JSON object With this library, you could write: Note that in all these cases, you never need to "tell" the compiler which JSON value type you want to use. If you want to be explicit or express some edge cases, the functions https://json.nlohmann.me/api/basicjson/array/ and https://json.nlohmann.me/api/basicjson/object/ will help: Serialization / Deserialization To/from strings You can create a JSON value deserialization by appending to a string literal: Note that without appending the suffix, the passed string literal is not parsed, but just used as JSON string value. That is, would just store the string rather than parsing the actual object. The string literal should be brought into scope with see https://json.nlohmann.me/api/operatorliteraljson/. The above example can also be expressed explicitly using https://json.nlohmann.me/api/basicjson/parse/: You can also get a string representation of a JSON value serialize: Note the difference between serialization and assignment: https://json.nlohmann.me/api/basicjson/dump/ returns the originally stored string value. Note the library only supports UTF-8. When you store strings with different encodings in the library, calling https://json.nlohmann.me/api/basicjson/dump/ may throw an exception unless or are used as error handlers. To/from streams e.g., files, string streams You can also use streams to serialize and deserialize: These operators work for any subclasses of or . Here is the same example with files: Please note that setting the exception bit for is inappropriate for this use case. It will result in program termination due to the specifier in use. Read from iterator range You can also parse JSON from an iterator range; that is, from any container accessible by iterators whose is an integral type of 1, 2, or 4 bytes, which will be interpreted as UTF-8, UTF-16, and UTF-32 respectively. For instance, a , or a : You may leave the iterators for the range begin, end: Custom data source Since the parse function accepts arbitrary iterator ranges, you can provide your own data sources by implementing the concept. SAX interface The library uses a SAX-like interface with the following functions: The return value of each function determines whether parsing should proceed. To implement your own SAX handler, proceed as follows: 1. Implement the SAX interface in a class. You can use class as base class, but you can also use any class where the functions described above are implemented and public. 2. Create an object of your SAX interface class, e.g. . 3. Call ; where the first parameter can be any input like a string or an input stream and the second parameter is a pointer to your SAX interface. Note the function only returns a indicating the result of the last executed SAX event. It does not return a value - it is up to you to decide what to do with the SAX events. Furthermore, no exceptions are thrown in case of a parse error -- it is up to you what to do with the exception object passed to your implementation. Internally, the SAX interface is used for the DOM parser class as well as the acceptor , see file . STL-like access We designed the JSON class to behave just like an STL container. In fact, it satisfies the ReversibleContainer requirement. Conversion from STL containers Any sequence container , , , , whose values can be used to construct JSON values e.g., integers, floating point numbers, Booleans, string types, or again STL containers described in this section can be used to create a JSON array. The same holds for similar associative containers , , , , but in these cases the order of the elements of the array depends on how the elements are ordered in the respective STL container. Likewise, any associative key-value containers , , , whose keys can construct an and whose values can be used to construct JSON values see examples above can be used to create a JSON object. Note that in case of multimaps, only one key is used in the JSON object and the value depends on the internal order of the STL container. JSON Pointer and JSON Patch The library supports JSON Pointer RFC 6901 as an alternative means to address structured values. On top of this, JSON Patch RFC 6902 allows describing differences between two JSON values -- effectively allowing patch and diff operations known from Unix. JSON Merge Patch The library supports JSON Merge Patch RFC 7386 as a patch format. Instead of using JSON Pointer see above to specify values to be manipulated, it describes the changes using a syntax that closely mimics the document being modified. Implicit conversions Supported types can be implicitly converted to JSON values. It is recommended to NOT USE implicit conversions FROM a JSON value. You can find more details about this recommendation here. You can switch off implicit conversions by defining to before including the header. When using CMake, you can also achieve this by setting the option to . Note that types are not automatically converted to JSON strings, but to integer numbers. A conversion to a string must be specified explicitly: Arbitrary types conversions Every type can be serialized in JSON, not just STL containers and scalar types. Usually, you would do something along those lines: It works, but that's quite a lot of boilerplate... Fortunately, there's a better way: Basic usage To make this work with one of your types, you only need to provide two functions: That's all! When calling the constructor with your type, your custom method will be automatically called. Likewise, when calling or , the method will be called. Some important things: - Those methods MUST be in your type's namespace which can be the global namespace, or the library will not be able to locate them in this example, they are in namespace , where is defined. - Those methods MUST be available e.g., proper headers must be included everywhere you use these conversions. Look at issue 1108 for errors that may occur otherwise. - When using , MUST be DefaultConstructible. There is a way to bypass this requirement described later. - In function , use function https://json.nlohmann.me/api/basicjson/at/ to access the object values rather than . In case a key does not exist, throws an exception that you can handle, whereas exhibits undefined behavior. - You do not need to add serializers or deserializers for STL types like : the library already implements these. Simplify your life with macros If you just want to serialize/deserialize some structs, the / functions can be a lot of boilerplate. There are several macros to make your life easier as long as you 1 want to use a JSON object as serialization and 2 want to use the member variable names as object keys in that object. Which macro to choose depends on whether private member variables need to be accessed, a deserialization is needed, missing values should yield an error or should be replaced by default values, and if derived classes are used. See this overview to choose the right one for your use case. Example usage of macros The / functions for the struct above can be created with https://json.nlohmann.me/api/macros/nlohmanndefinetypenonintrusive/. In all macros, the first parameter is the name of the class/struct, and all remaining parameters name the members. Here is another example with private members, where https://json.nlohmann.me/api/macros/nlohmanndefinetypeintrusive/ is needed: How do I convert third-party types? This requires a bit more advanced technique. But first, let's see how this conversion mechanism works: The library uses JSON Serializers to convert types to JSON. The default serializer for is ADL means Argument-Dependent Lookup. It is implemented like this simplified: This serializer works fine when you have control over the type's namespace. However, what about or C++17? Hijacking the namespace is pretty bad, and it's illegal to add something other than template specializations to ... To solve this, you need to add a specialization of to the namespace, here's an example: How can I use for non-default constructible/non-copyable types? There is a way if your type is MoveConstructible. You will need to specialize the as well, but with a special overload: Can I write my own serializer? Advanced use Yes. You might want to take a look at https://github.com/nlohmann/json/blob/develop/tests/src/unit-udt.cpp in the test suite, to see a few examples. If you write your own serializer, you'll need to do a few things: - use a different alias than the last template parameter of is the - use your alias or a template parameter in all your / methods - use and when you need ADL Here is an example, without simplifications, that only accepts types with a size <= 32, and uses ADL. Be very careful when reimplementing your serializer, you can stack overflow if you don't pay attention: Specializing enum conversion By default, enum values are serialized to JSON as integers. In some cases, this could result in undesired behavior. If an enum is modified or re-ordered after data has been serialized to JSON, the later deserialized JSON data may be undefined or a different enum value than was originally intended. It is possible to more precisely specify how a given enum is mapped to and from JSON as shown below: The macro declares a set of / functions for type while avoiding repetition and boilerplate serialization code. Usage: Just as in Arbitrary Type Conversions above, - MUST be declared in your enum type's namespace which can be the global namespace, or the library will not be able to locate it, and it will default to integer serialization. - It MUST be available e.g., proper headers must be included everywhere you use the conversions. Other Important points: - When using , undefined JSON values will default to the first pair specified in your map. Select this default pair carefully. - If an enum or JSON value is specified more than once in your map, the first matching occurrence from the top of the map will be returned when converting to or from JSON. Binary formats BSON, CBOR, MessagePack, UBJSON, and BJData Though JSON is a ubiquitous data format, it is not a very compact format suitable for data exchange, for instance over a network. Hence, the library supports BSON Binary JSON, CBOR Concise Binary Object Representation, MessagePack, UBJSON Universal Binary JSON Specification and BJData Binary JData to efficiently encode JSON values to byte vectors and to decode such vectors. The library also supports binary types from BSON, CBOR byte strings, and MessagePack bin, ext, fixext. They are stored by default as to be processed outside the library. Customers The library is used in multiple projects, applications, operating systems, etc. The list below is not exhaustive, but the result of an internet search. If you know further customers of the library, please let me know, see contact. !logos of customers using the libraryhttps://json.nlohmann.me/home/customers/ Supported compilers Though it's 2025 already, the support for C++11 is still a bit sparse. Currently, the following compilers are known to work: - GCC 4.8 - 14.2 and possibly later - Clang 3.4 - 21.0 and possibly later - Apple Clang 9.1 - 16.0 and possibly later - Intel C++ Compiler 17.0.2 and possibly later - Nvidia CUDA Compiler 11.0.221 and possibly later - Microsoft Visual C++ 2015 / Build Tools 14.0.25123.0 and possibly later - Microsoft Visual C++ 2017 / Build Tools 15.5.180.51428 and possibly later - Microsoft Visual C++ 2019 / Build Tools 16.3.1+1def00d3d and possibly later - Microsoft Visual C++ 2022 / Build Tools 19.30.30709.0 and possibly later I would be happy to learn about other compilers/versions. Please note: - GCC 4.8 has a bug 57824: multiline raw strings cannot be the arguments to macros. Don't use multiline raw strings directly in macros with this compiler. - Android defaults to using very old compilers and C++ libraries. To fix this, add the following to your . This will switch to the LLVM C++ library, the Clang compiler, and enable C++11 and other features disabled by default. The code compiles successfully with Android NDK, Revision 9 - 11 and possibly later and CrystaX's Android NDK version 10. - For GCC running on MinGW or Android SDK, the error or similarly, for or may occur. Note this is not an issue with the code, but rather with the compiler itself. On Android, see above to build with a newer environment. For MinGW, please refer to this site and this discussion for information on how to fix this bug. For Android NDK using , please refer to this discussion. - Unsupported versions of GCC and Clang are rejected by directives. This can be switched off by defining . Note that you can expect no support in this case. See the page quality assurance on the compilers used to check the library in the CI. Integration https://github.com/nlohmann/json/blob/develop/singleinclude/nlohmann/json.hpp is the single required file in or released here. You need to add to the files you want to process JSON and set the necessary switches to enable C++11 e.g., for GCC and Clang. You can further use file https://github.com/nlohmann/json/blob/develop/include/nlohmann/jsonfwd.hpp for forward-declarations. The installation of as part of cmake's install step can be achieved by setting . CMake You can also use the interface target in CMake. This target populates the appropriate usage requirements for to point to the appropriate include directories and for the necessary C++11 flags. External To use this library from a CMake project, you can locate it directly with and use the namespaced imported target from the generated package configuration: The package configuration file, , can be used either from an install tree or directly out of the build tree. Embedded To embed the library directly into an existing CMake project, place the entire source tree in a subdirectory and call in your file: Embedded FetchContent Since CMake v3.11, FetchContent can be used to automatically download a release as a dependency at configure time. Example: Note: It is recommended to use the URL approach described above, which is supported as of version 3.10.0. See <https://json.nlohmann.me/integration/cmake/fetchcontent> for more information. Supporting Both To allow your project to support either an externally supplied or an embedded JSON library, you can use a pattern akin to the following: is then a complete copy of this source tree. Package Managers Use your favorite package manager to use the library. - <img src="https://raw.githubusercontent.com/nlohmann/json/refs/heads/develop/docs/mkdocs/docs/images/packagemanagers/homebrew.svg" height="20">&nbsp;Homebrew - <img src="https://raw.githubusercontent.com/nlohmann/json/refs/heads/develop/docs/mkdocs/docs/images/packagemanagers/meson.svg" height="20">&nbsp;Meson - <img src="https://raw.githubusercontent.com/nlohmann/json/refs/heads/develop/docs/mkdocs/docs/images/packagemanagers/bazel.svg" height="20">&nbsp;Bazel - <img src="https://raw.githubusercontent.com/nlohmann/json/refs/heads/develop/docs/mkdocs/docs/images/packagemanagers/conan.svg" height="20">&nbsp;Conan - <img src="https://raw.githubusercontent.com/nlohmann/json/refs/heads/develop/docs/mkdocs/docs/images/packagemanagers/spack.svg" height="20">&nbsp;Spack - Hunter - <img src="https://raw.githubusercontent.com/nlohmann/json/refs/heads/develop/docs/mkdocs/docs/images/packagemanagers/vcpkg.png" height="20">&nbsp;vcpkg - cget - <img src="https://raw.githubusercontent.com/nlohmann/json/refs/heads/develop/docs/mkdocs/docs/images/packagemanagers/swift.svg" height="20">&nbsp;Swift Package Manager - <img src="https://raw.githubusercontent.com/nlohmann/json/refs/heads/develop/docs/mkdocs/docs/images/packagemanagers/nuget.svg" height="20">&nbsp;Nuget - <img src="https://raw.githubusercontent.com/nlohmann/json/refs/heads/develop/docs/mkdocs/docs/images/packagemanagers/conda.svg" height="20">&nbsp;Conda - <img src="https://raw.githubusercontent.com/nlohmann/json/refs/heads/develop/docs/mkdocs/docs/images/packagemanagers/macports.svg" height="20">&nbsp;MacPorts - <img src="https://raw.githubusercontent.com/nlohmann/json/refs/heads/develop/docs/mkdocs/docs/images/packagemanagers/CPM.png" height="20">&nbsp;cpm.cmake - <img src="https://raw.githubusercontent.com/nlohmann/json/refs/heads/develop/docs/mkdocs/docs/images/packagemanagers/xmake.svg" height="20">&nbsp;xmake The library is part of many package managers. See the documentation for detailed descriptions and examples. Pkg-config If you are using bare Makefiles, you can use to generate the include flags that point to where the library is installed: License <img align="right" src="https://149753425.v2.pressablecdn.com/wp-content/uploads/2009/06/OSIApproved100X125.png" alt="OSI approved license"> The class is licensed under the MIT License: Copyright &copy; 2013-2025 Niels Lohmann Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files the “Software”, to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. - The class contains the UTF-8 Decoder from Bjoern Hoehrmann which is licensed under the MIT License see above. Copyright &copy; 2008-2009 Björn Hoehrmann <bjoern@hoehrmann.de> - The class contains a slightly modified version of the Grisu2 algorithm from Florian Loitsch which is licensed under the MIT License see above. Copyright &copy; 2009 Florian Loitsch - The class contains a copy of Hedley from Evan Nemerson which is licensed as CC0-1.0. - The class contains parts of Google Abseil which is licensed under the Apache 2.0 License. <img align="right" src="https://git.fsfe.org/reuse/reuse-ci/raw/branch/master/reuse-horizontal.png" alt="REUSE Software"> The library is compliant to version 3.3 of the REUSE specification: - Every source file contains an SPDX copyright header. - The full text of all licenses used in the repository can be found in the folder. - File contains an overview of all files' copyrights and licenses. - Run to verify the project's REUSE compliance and to generate a SPDX SBOM. Contact If you have questions regarding the library, I would like to invite you to open an issue at GitHub. Please describe your request, problem, or question as detailed as possible, and also mention the version of the library you are using as well as the version of your compiler and operating system. Opening an issue at GitHub allows other users and contributors to this library to collaborate. For instance, I have little experience with MSVC, and most issues in this regard have been solved by a growing community. If you have a look at the closed issues, you will see that we react quite timely in most cases. Only if your request would contain confidential information, please send me an email. For encrypted messages, please use this key. Security Commits by Niels Lohmann and releases are signed with this PGP Key. Thanks I deeply appreciate the help of the following people. <img src="https://raw.githubusercontent.com/nlohmann/json/develop/docs/avatars.png" align="right" alt="GitHub avatars of the contributors"> 1. Teemperor implemented CMake support and lcov integration, realized escape and Unicode handling in the string parser, and fixed the JSON serialization. 2. elliotgoodrich fixed an issue with double deletion in the iterator classes. 3. kirkshoop made the iterators of the class composable to other libraries. 4. wancw fixed a bug that hindered the class to compile with Clang. 5. Tomas Åblad found a bug in the iterator implementation. 6. Joshua C. Randall fixed a bug in the floating-point serialization. 7. Aaron Burghardt implemented code to parse streams incrementally. Furthermore, he greatly improved the parser class by allowing the definition of a filter function to discard undesired elements while parsing. 8. Daniel Kopeček fixed a bug in the compilation with GCC 5.0. 9. Florian Weber fixed a bug in and improved the performance of the comparison operators. 10. Eric Cornelius pointed out a bug in the handling with NaN and infinity values. He also improved the performance of the string escaping. 11. 易思龙 implemented a conversion from anonymous enums. 12. kepkin patiently pushed forward the support for Microsoft Visual Studio. 13. gregmarr simplified the implementation of reverse iterators and helped with numerous hints and improvements. In particular, he pushed forward the implementation of user-defined types. 14. Caio Luppi fixed a bug in the Unicode handling. 15. dariomt fixed some typos in the examples. 16. Daniel Frey cleaned up some pointers and implemented exception-safe memory allocation. 17. Colin Hirsch took care of a small namespace issue. 18. Huu Nguyen corrected a variable name in the documentation. 19. Silverweed overloaded to accept an rvalue reference. 20. dariomt fixed a subtlety in MSVC type support and implemented the function to get a reference to stored values. 21. ZahlGraf added a workaround that allows compilation using Android NDK. 22. whackashoe replaced a function that was marked as unsafe by Visual Studio. 23. 406345 fixed two small warnings. 24. Glen Fernandes noted a potential portability problem in the function. 25. Corbin Hughes fixed some typos in the contribution guidelines. 26. twelsby fixed the array subscript operator, an issue that failed the MSVC build, and floating-point parsing/dumping. He further added support for unsigned integer numbers and implemented better roundtrip support for parsed numbers. 27. Volker Diels-Grabsch fixed a link in the README file. 28. msm- added support for American Fuzzy Lop. 29. Annihil fixed an example in the README file. 30. Themercee noted a wrong URL in the README file. 31. Lv Zheng fixed a namespace issue with and . 32. abc100m analyzed the issues with GCC 4.8 and proposed a partial solution. 33. zewt added useful notes to the README file about Android. 34. Róbert Márki added a fix to use move iterators and improved the integration via CMake. 35. Chris Kitching cleaned up the CMake files. 36. Tom Needham fixed a subtle bug with MSVC 2015 which was also proposed by Michael K.. 37. Mário Feroldi fixed a small typo. 38. duncanwerner found a really embarrassing performance regression in the 2.0.0 release. 39. Damien fixed one of the last conversion warnings. 40. Thomas Braun fixed a warning in a test case and adjusted MSVC calls in the CI. 41. Théo DELRIEU patiently and constructively oversaw the long way toward iterator-range parsing. He also implemented the magic behind the serialization/deserialization of user-defined types and split the single header file into smaller chunks. 42. Stefan fixed a minor issue in the documentation. 43. Vasil Dimov fixed the documentation regarding conversions from . 44. ChristophJud overworked the CMake files to ease project inclusion. 45. Vladimir Petrigo made a SFINAE hack more readable and added Visual Studio 17 to the build matrix. 46. Denis Andrejew fixed a grammar issue in the README file. 47. Pierre-Antoine Lacaze found a subtle bug in the function. 48. TurpentineDistillery pointed to https://en.cppreference.com/w/cpp/locale/locale/classic to avoid too much locale joggling, found some nice performance improvements in the parser, improved the benchmarking code, and realized locale-independent number parsing and printing. 49. cgzones had an idea how to fix the Coverity scan. 50. Jared Grubb silenced a nasty documentation warning. 51. Yixin Zhang fixed an integer overflow check. 52. Bosswestfalen merged two iterator classes into a smaller one. 53. Daniel599 helped to get Travis to execute the tests with Clang's sanitizers. 54. Jonathan Lee fixed an example in the README file. 55. gnzlbg supported the implementation of user-defined types. 56. Alexej Harm helped to get the user-defined types working with Visual Studio. 57. Jared Grubb supported the implementation of user-defined types. 58. EnricoBilla noted a typo in an example. 59. Martin Hořeňovský found a way for a 2x speedup for the compilation time of the test suite. 60. ukhegg found proposed an improvement for the examples section. 61. rswanson-ihi noted a typo in the README. 62. Mihai Stan fixed a bug in the comparison with s. 63. Tushar Maheshwari added cotire support to speed up the compilation. 64. TedLyngmo noted a typo in the README, removed unnecessary bit arithmetic, and fixed some warnings. 65. Krzysztof Woś made exceptions more visible. 66. ftillier fixed a compiler warning. 67. tinloaf made sure all pushed warnings are properly popped. 68. Fytch found a bug in the documentation. 69. Jay Sistar implemented a Meson build description. 70. Henry Lee fixed a warning in ICC and improved the iterator implementation. 71. Vincent Thiery maintains a package for the Conan package manager. 72. Steffen fixed a potential issue with MSVC and . 73. Mike Tzou fixed some typos. 74. amrcode noted misleading documentation about comparison of floats. 75. Oleg Endo reduced the memory consumption by replacing with . 76. dan-42 cleaned up the CMake files to simplify including/reusing of the library. 77. Nikita Ofitserov allowed for moving values from initializer lists. 78. Greg Hurrell fixed a typo. 79. Dmitry Kukovinets fixed a typo. 80. kbthomp1 fixed an issue related to the Intel OSX compiler. 81. Markus Werle fixed a typo. 82. WebProdPP fixed a subtle error in a precondition check. 83. Alex noted an error in a code sample. 84. Tom de Geus reported some warnings with ICC and helped to fix them. 85. Perry Kundert simplified reading from input streams. 86. Sonu Lohani fixed a small compilation error. 87. Jamie Seward fixed all MSVC warnings. 88. Nate Vargas added a Doxygen tag file. 89. pvleuven helped to fix a warning in ICC. 90. Pavel helped to fix some warnings in MSVC. 91. Jamie Seward avoided unnecessary string copies in and . 92. Mitja fixed some typos. 93. Jorrit Wronski updated the Hunter package links. 94. Matthias Möller added a for the MSVC debug view. 95. bogemic fixed some C++17 deprecation warnings. 96. Eren Okka fixed some MSVC warnings. 97. abolz integrated the Grisu2 algorithm for proper floating-point formatting, allowing more roundtrip checks to succeed. 98. Vadim Evard fixed a Markdown issue in the README. 99. zerodefect fixed a compiler warning. 100. Kert allowed to template the string type in the serialization and added the possibility to override the exceptional behavior. 101. mark-99 helped fix an ICC error. 102. Patrik Huber fixed links in the README file. 103. johnfb found a bug in the implementation of CBOR's indefinite length strings. 104. Paul Fultz II added a note on the cget package manager. 105. Wilson Lin made the integration section of the README more concise. 106. RalfBielig detected and fixed a memory leak in the parser callback. 107. agrianius allowed dumping JSON to an alternative string type. 108. Kevin Tonon overworked the C++11 compiler checks in CMake. 109. Axel Huebl simplified a CMake check and added support for the Spack package manager. 110. Carlos O'Ryan fixed a typo. 111. James Upjohn fixed a version number in the compilers section. 112. Chuck Atkins adjusted the CMake files to the CMake packaging guidelines and provided documentation for the CMake integration. 113. Jan Schöppach fixed a typo. 114. martin-mfg fixed a typo. 115. Matthias Möller removed the dependency from . 116. agrianius added code to use alternative string implementations. 117. Daniel599 allowed to use more algorithms with the function. 118. Julius Rakow fixed the Meson include directory and fixed the links to cppreference.com. 119. Sonu Lohani fixed the compilation with MSVC 2015 in debug mode. 120. grembo fixed the test suite and re-enabled several test cases. 121. Hyeon Kim introduced the macro to control the exception handling inside the library. 122. thyu fixed a compiler warning. 123. David Guthrie fixed a subtle compilation error with Clang 3.4.2. 124. Dennis Fischer allowed to call without installing the library. 125. Hyeon Kim fixed an issue with a double macro definition. 126. Ben Berman made some error messages more understandable. 127. zakalibit fixed a compilation problem with the Intel C++ compiler. 128. mandreyel fixed a compilation problem. 129. Kostiantyn Ponomarenko added version and license information to the Meson build file. 130. Henry Schreiner added support for GCC 4.8. 131. knilch made sure the test suite does not stall when run in the wrong directory. 132. Antonio Borondo fixed an MSVC 2017 warning. 133. Dan Gendreau implemented the macro to quickly define an enum/JSON mapping. 134. efp added line and column information to parse errors. 135. julian-becker added BSON support. 136. Pratik Chowdhury added support for structured bindings. 137. David Avedissian added support for Clang 5.0.1 PS4 version. 138. Jonathan Dumaresq implemented an input adapter to read from . 139. kjpus fixed a link in the documentation. 140. Manvendra Singh fixed a typo in the documentation. 141. ziggurat29 fixed an MSVC warning. 142. Sylvain Corlay added code to avoid an issue with MSVC. 143. mefyl fixed a bug when JSON was parsed from an input stream. 144. Millian Poquet allowed to install the library via Meson. 145. Michael Behrns-Miller found an issue with a missing namespace. 146. Nasztanovics Ferenc fixed a compilation issue with libc 2.12. 147. Andreas Schwab fixed the endian conversion. 148. Mark-Dunning fixed a warning in MSVC. 149. Gareth Sylvester-Bradley added for JSON Pointers. 150. John-Mark noted a missing header. 151. Vitaly Zaitsev fixed compilation with GCC 9.0. 152. Laurent Stacul fixed compilation with GCC 9.0. 153. Ivor Wanders helped to reduce the CMake requirement to version 3.1. 154. njlr updated the Buckaroo instructions. 155. Lion fixed a compilation issue with GCC 7 on CentOS. 156. Isaac Nickaein improved the integer serialization performance and implemented the function. 157. past-due suppressed an unfixable warning. 158. Elvis Oric improved Meson support. 159. Matěj Plch fixed an example in the README. 160. Mark Beckwith fixed a typo. 161. scinart fixed a bug in the serializer. 162. Patrick Boettcher implemented and for JSON Pointers. 163. Bruno Oliveira added support for Conda. 164. Michele Caini fixed links in the README. 165. Hani documented how to install the library with NuGet. 166. Mark Beckwith fixed a typo. 167. yann-morin-1998 helped to reduce the CMake requirement to version 3.1. 168. Konstantin Podsvirov maintains a package for the MSYS2 software distro. 169. remyabel added GNUInstallDirs to the CMake files. 170. Taylor Howard fixed a unit test. 171. Gabe Ron implemented the method. 172. Watal M. Iwasaki fixed a Clang warning. 173. Viktor Kirilov switched the unit tests from Catch to doctest 174. Juncheng E fixed a typo. 175. tete17 fixed a bug in the function. 176. Xav83 fixed some cppcheck warnings. 177. 0xflotus fixed some typos. 178. Christian Deneke added a const version of . 179. Julien Hamaide made the function work with custom string types. 180. Evan Nemerson updated fixed a bug in Hedley and updated this library accordingly. 181. Florian Pigorsch fixed a lot of typos. 182. Camille Bégué fixed an issue in the conversion from and to . 183. Anthony VH fixed a compile error in an enum deserialization. 184. Yuriy Vountesmery noted a subtle bug in a preprocessor check. 185. Chen fixed numerous issues in the library. 186. Antony Kellermann added a CI step for GCC 10.1. 187. Alex fixed an MSVC warning. 188. Rainer proposed an improvement in the floating-point serialization in CBOR. 189. Francois Chabot made performance improvements in the input adapters. 190. Arthur Sonzogni documented how the library can be included via . 191. Rimas Misevičius fixed an error message. 192. Alexander Myasnikov fixed some examples and a link in the README. 193. Hubert Chathi made CMake's version config file architecture-independent. 194. OmnipotentEntity implemented the binary values for CBOR, MessagePack, BSON, and UBJSON. 195. ArtemSarmini fixed a compilation issue with GCC 10 and fixed a leak. 196. Evgenii Sopov integrated the library to the wsjcpp package manager. 197. Sergey Linev fixed a compiler warning. 198. Miguel Magalhães fixed the year in the copyright. 199. Gareth Sylvester-Bradley fixed a compilation issue with MSVC. 200. Alexander “weej” Jones fixed an example in the README. 201. Antoine Cœur fixed some typos in the documentation. 202. jothepro updated links to the Hunter package. 203. Dave Lee fixed a link in the README. 204. Joël Lamotte added instruction for using Build2's package manager. 205. Paul Jurczak fixed an example in the README. 206. Sonu Lohani fixed a warning. 207. Carlos Gomes Martinho updated the Conan package source. 208. Konstantin Podsvirov fixed the MSYS2 package documentation. 209. Tridacnid improved the CMake tests. 210. Michael fixed MSVC warnings. 211. Quentin Barbarat fixed an example in the documentation. 212. XyFreak fixed a compiler warning. 213. TotalCaesar659 fixed links in the README. 214. Tanuj Garg improved the fuzzer coverage for UBSAN input. 215. AODQ fixed a compiler warning. 216. jwittbrodt made inline. 217. pfeatherstone improved the upper bound of arguments of the / macros. 218. Jan Procházka fixed a bug in the CBOR parser for binary and string values. 219. T0b1-iOS fixed a bug in the new hash implementation. 220. Matthew Bauer adjusted the CBOR writer to create tags for binary subtypes. 221. gatopeich implemented an ordered map container for . 222. Érico Nogueira Rolim added support for pkg-config. 223. KonanM proposed an implementation for the / macros. 224. Guillaume Racicot implemented support and allowed C++20 support. 225. Alex Reinking improved CMake support for . 226. Hannes Domani provided a GDB pretty printer. 227. Lars Wirzenius reviewed the README file. 228. Jun Jie fixed a compiler path in the CMake scripts. 229. Ronak Buch fixed typos in the documentation. 230. Alexander Karzhenkov fixed a move constructor and the Travis builds. 231. Leonardo Lima added CPM.Cmake support. 232. Joseph Blackman fixed a warning. 233. Yaroslav updated doctest and implemented unit tests. 234. Martin Stump fixed a bug in the CMake files. 235. Jaakko Moisio fixed a bug in the input adapters. 236. bl-ue fixed some Markdown issues in the README file. 237. William A. Wieselquist fixed an example from the README. 238. abbaswasim fixed an example from the README. 239. Remy Jette fixed a warning. 240. Fraser fixed the documentation. 241. Ben Beasley updated doctest. 242. Doron Behar fixed pkg-config.pc. 243. raduteo fixed a warning. 244. David Pfahler added the possibility to compile the library without I/O support. 245. Morten Fyhn Amundsen fixed a typo. 246. jpl-mac allowed treating the library as a system header in CMake. 247. Jason Dsouza fixed the indentation of the CMake file. 248. offa added a link to Conan Center to the documentation. 249. TotalCaesar659 updated the links in the documentation to use HTTPS. 250. Rafail Giavrimis fixed the Google Benchmark default branch. 251. Louis Dionne fixed a conversion operator. 252. justanotheranonymoususer made the examples in the README more consistent. 253. Finkman suppressed some warnings. 254. Ferry Huberts fixed warnings. 255. Arseniy Terekhin made the GDB pretty-printer robust against unset variable names. 256. Amir Masoud Abdol updated the Homebrew command as nlohmann/json is now in homebrew-core. 257. Hallot fixed some . 258. Giovanni Cerretani fixed warnings on . 259. Bogdan Popescu hosts the docset for offline documentation viewers. 260. Carl Smedstad fixed an assertion error when using . 261. miikka75 provided an important fix to compile C++17 code with Clang 9. 262. Maarten Becker fixed a warning for shadowed variables. 263. Cristi Vîjdea fixed typos in the documentation. 264. Alex Beregszaszi fixed spelling mistakes in comments. 265. Dirk Stolle fixed typos in documentation. 266. Daniel Albuschat corrected the parameter name in the documentation. 267. Prince Mendiratta fixed a link to the FAQ. 268. Florian Albrechtskirchinger implemented support for object keys and made dozens of other improvements. 269. Qianqian Fang implemented the Binary JData BJData format. 270. pketelsen added macros and . 271. DarkZeros adjusted to code to not clash with Arduino defines. 272. flagarde fixed the output of for MSVC. 273. Giovanni Cerretani fixed a check for . 274. Dimitris Apostolou fixed a typo. 275. Ferry Huberts fixed a typo. 276. Michael Nosthoff fixed a typo. 277. JungHoon Lee fixed a typo. 278. Faruk D. fixed the CITATION.CFF file. 279. Andrea Cocito added a clarification on macro usage to the documentation. 280. Krzysiek Karbowiak refactored the tests to use . 281. Chaoqi Zhang fixed a typo. 282. ivanovmp fixed a whitespace error. 283. KsaNL fixed a build error when including . 284. Andrea Pappacoda moved and files to directory. 285. Wolf Vollprecht added the function. 286. Jake Zimmerman highlighted common usage patterns in the README file. 287. NN added the Visual Studio output directory to . 288. Romain Reignier improved the performance of the vector output adapter. 289. Mike fixed the . 290. Richard Hozák added macro to disable default enum conversions. 291. vakokako fixed tests when compiling with C++20. 292. Alexander “weej” Jones fixed an example in the README. 293. Eli Schwartz added more files to the archive. 294. Kevin Lu fixed a compilation issue when typedefs with certain names were present. 295. Trevor Hickey improved the description of an example. 296. Jef LeCompte updated the year in the README file. 297. Alexandre Hamez fixed a warning. 298. Maninderpal Badhan fixed a typo. 299. kevin-- added a note to an example in the README file. 300. I fixed a typo. 301. Gregorio Litenstein fixed the Clang detection. 302. Andreas Smas added a Doozer badge. 303. WanCW fixed the string conversion with Clang. 304. zhaohuaxishi fixed a Doxygen error. 305. emvivre removed an invalid parameter from CMake. 306. Tobias Hermann fixed a link in the README file. 307. Michael fixed a warning. 308. Ryan Mulder added to the function. 309. Muri Nicanor fixed the discovery in the Makefile. 310. David Avedissian implemented SFINAE-friendly . 311. AQNOUCH Mohammed fixed a typo in the README. 312. Gareth Sylvester-Bradley added and to construct JSON pointers. 313. Michael Macnair added support for afl-fuzz testing. 314. Berkus Decker fixed a typo in the README. 315. Illia Polishchuk improved the CMake testing. 316. Ikko Ashimine fixed a typo. 317. Raphael Grimm added the possibility to define a custom base class. 318. tocic fixed typos in the documentation. 319. Vertexwahn added Bazel build support. 320. Dirk Stolle fixed typos in the documentation. 321. DavidKorczynski added a CIFuzz CI GitHub action. 322. Finkman fixed the debug pretty-printer. 323. Florian Segginger bumped the years in the README. 324. haadfida cleaned up the badges of used services. 325. Arsen Arsenović fixed a build error. 326. theevilone45 fixed a typo in a CMake file. 327. Sergei Trofimovich fixed the custom allocator support. 328. Joyce fixed some security issues in the GitHub workflows. 329. Nicolas Jakob add vcpkg version badge. 330. Tomerkm added tests. 331. No. fixed the use of calls. 332. taro fixed a typo in the file. 333. Ikko Eltociear Ashimine fixed a typo. 334. Felix Yan fixed a typo in the README. 335. HO-COOH fixed a parenthesis in the documentation. 336. Ivor Wanders fixed the examples to catch exception by . 337. miny1233 fixed a parenthesis in the documentation. 338. tomalakgeretkal fixed a compilation error. 339. alferov fixed a compilation error. 340. Craig Scott fixed a deprecation warning in CMake. 341. Vyacheslav Zhdanovskiy added macros for serialization-only types. 342. Mathieu Westphal fixed typos. 343. scribam fixed the MinGW workflow. 344. Aleksei Sapitskii added support for Apple's Swift Package Manager. 345. Benjamin Buch fixed the installation path in CMake. 346. Colby Haskell clarified the parse error message in case a file cannot be opened. 347. Juan Carlos Arevalo Baeza fixed the enum conversion. 348. alferov fixed a version in the documentation. 349. ss fixed the amalgamation call. 350. AniketDhemare fixed a version in the documentation. 351. Philip Müller fixed an example. 352. Leila Shcheglova fixed a warning in a test. 353. Alex Prabhat Bara fixed a function name in the documentation. 354. laterlaugh fixed some typos. 355. Yuanhao Jia fixed the GDB pretty printer. 356. FallenBreath fixed an example for JSON Pointer. 357. Nikhil Idiculla fixed some typos. 358. Griffin Myers updated the Natvis file. 359. thetimr fixed a typo in the documentation. 360. Balazs Erseki fixed a URL in the contribution guidelines. 361. Niccolò Iardella added macros. 362. Borislav Stanimirov allowed overriding the CMake target name. 363. Captain Crutches made a . 364. Fredrik Sandhei added type conversion support for . 365. jh96 added exceptions when is passed to . 366. Stuart Gorman fixed number parsing when set in . 367. Dylan Baker generated a pkg-config file that follows the pkg-config conventions. 368. Tianyi Chen optimized the binary implementation. 369. peng-wang-cn added type conversion support for multidimensional arrays. 370. Einars Netlis-Galejs added for macros. 371. Marcel removed Bazel flag. 372. Harinath Nampally added diagnostic positions to exceptions. 373. Nissim Armand Ben Danan fixed with an empty JSON instance. 374. Michael Valladolid added support for BSON uint64 serialization/deserialization. 375. Nikhil updated the documentation. 376. Nebojša Cvetković added support for BJDATA optimized binary array type. 377. Sushrut Shringarputale added support for diagnostic positions. 378. kimci86 templated to macros to also support . 379. Richard Topchii added support for VisionOS in the Swift Package Manager. 380. Robert Chisholm fixed a typo. 381. zjyhjqs added CPack support. 382. bitFiedler made GDB pretty printer work with Python 3.8. 383. Gianfranco Costamagna fixed a compiler warning. 384. risa2000 made conversion to/from UTF-8 encoded string explicit. Thanks a lot for helping out! Please let me know if I forgot someone. Used third-party tools The library itself consists of a single header file licensed under the MIT license. However, it is built, tested, documented, and whatnot using a lot of third-party tools and services. Thanks a lot! - amalgamate.py - Amalgamate C source and header files to create a single header file - American fuzzy lop for fuzz testing - AppVeyor for continuous integration on Windows - Artistic Style for automatic source code indentation - Clang for compilation with code sanitizers - CMake for build automation - Codacy for further code analysis - Coveralls to measure code coverage - Coverity Scan for static analysis - cppcheck for static analysis - doctest for the unit tests - GitHub Changelog Generator to generate the ChangeLog - Google Benchmark to implement the benchmarks - Hedley to avoid re-inventing several compiler-agnostic feature macros - lcov to process coverage information and create an HTML view - libFuzzer to implement fuzz testing for OSS-Fuzz - Material for MkDocs for the style of the documentation site - MkDocs for the documentation site - OSS-Fuzz for continuous fuzz testing of the library project repository - Probot for automating maintainer tasks such as closing stale issues, requesting missing information, or detecting toxic comments. - Valgrind to check for correct memory management Notes Character encoding The library supports Unicode input as follows: - Only UTF-8 encoded input is supported, which is the default encoding for JSON according to RFC 8259. - and can be parsed, assuming UTF-16 and UTF-32 encoding, respectively. These encodings are not supported when reading from files or other input containers. - Other encodings such as Latin-1 or ISO 8859-1 are not supported and will yield parse or serialization errors. - Unicode noncharacters will not be replaced by the library. - Invalid surrogates e.g., incomplete pairs such as will yield parse errors. - The strings stored in the library are UTF-8 encoded. When using the default string type , note that its length/size functions return the number of stored bytes rather than the number of characters or glyphs. - When you store strings with different encodings in the library, calling https://json.nlohmann.me/api/basicjson/dump/ may throw an exception unless or are used as error handlers. - To store wide strings e.g., , you need to convert them to a UTF-8 encoded before, see an example. Comments in JSON This library does not support comments by default. It does so for three reasons: 1. Comments are not part of the JSON specification. You may argue that or are allowed in JavaScript, but JSON is not JavaScript. 2. This was not an oversight: Douglas Crockford wrote on this in May 2012: > I removed comments from JSON because I saw people were using them to hold parsing directives, a practice which would have destroyed interoperability. I know that the lack of comments makes some people sad, but it shouldn't. > > Suppose you are using JSON to keep configuration files, which you would like to annotate. Go ahead and insert all the comments you like. Then pipe it through JSMin before handing it to your JSON parser. 3. It is dangerous for interoperability if some libraries would add comment support while others don't. Please check The Harmful Consequences of the Robustness Principle on this. However, you can set set parameter to true in the function to ignore or comments. Comments will then be treated as whitespace. Trailing commas The JSON specification does not allow trailing commas in arrays and objects, and hence this library is treating them as parsing errors by default. Like comments, you can set parameter to true in the function to ignore trailing commas in arrays and objects. Note that a single comma as the only content of the array or object or is not allowed, and multiple trailing commas are not allowed either. This library does not add trailing commas when serializing JSON data. For more information, see JSON With Commas and Comments JWCC. Order of object keys By default, the library does not preserve the insertion order of object elements. This is standards-compliant, as the JSON standard defines objects as "an unordered collection of zero or more name/value pairs". If you do want to preserve the insertion order, you can try the type https://github.com/nlohmann/json/issues/2179. Alternatively, you can use a more sophisticated ordered map like https://github.com/Tessil/ordered-map integration or https://github.com/nlohmann/fifomap integration. See the documentation on object order for more information. Memory Release We checked with Valgrind and the Address Sanitizer ASAN that there are no memory leaks. If you find that a parsing program with this library does not release memory, please consider the following case, and it may be unrelated to this library. Your program is compiled with glibc. There is a tunable threshold that glibc uses to decide whether to actually return memory to the system or whether to cache it for later reuse. If in your program you make lots of small allocations and those small allocations are not a contiguous block and are presumably below the threshold, then they will not get returned to the OS. Here is a related issue 1924. Further notes - The code contains numerous debug assertions which can be switched off by defining the preprocessor macro , see the documentation of . In particular, note https://json.nlohmann.me/api/basicjson/operator%5B%5D/ implements unchecked access for const objects: If the given key is not present, the behavior is undefined think of a dereferenced null pointer and yields an assertion failure if assertions are switched on. If you are not sure whether an element in an object exists, use checked access with the function. Furthermore, you can define to replace calls to . See the documentation on runtime assertions for more information. - As the exact number type is not defined in the JSON specification, this library tries to choose the best fitting C++ number type automatically. As a result, the type may be used to store numbers which may yield floating-point exceptions in certain rare situations if floating-point exceptions have been unmasked in the calling code. These exceptions are not caused by the library and need to be fixed in the calling code, such as by re-masking the exceptions prior to calling library functions. - The code can be compiled without C++ runtime type identification features; that is, you can use the compiler flag. - Exceptions are used widely within the library. They can, however, be switched off with either using the compiler flag or by defining the symbol . In this case, exceptions are replaced by calls. You can further control this behavior by defining overriding , overriding , and overriding . Note that should leave the current scope e.g., by throwing or aborting, as continuing after it may yield undefined behavior. Note the explanatory https://en.cppreference.com/w/cpp/error/exception/what string of exceptions is not available for MSVC if exceptions are disabled, see 2824. See the documentation of exceptions for more information. Execute unit tests To compile and run the tests, you need to execute Note that during the stage, several JSON test files are downloaded from an external repository. If policies forbid downloading artifacts during testing, you can download the files yourself and pass the directory with the test files via to CMake. Then, no Internet connectivity is required. See issue 2189 for more information. If the test suite is not found, several test suites will fail like this: In case you have downloaded the library rather than checked out the code via Git, test will fail. Please execute to skip these tests. See issue 2189 for more information. Some tests change the installed files and hence make the whole process not reproducible. Please execute to skip these tests. See issue 2324 for more information. Furthermore, assertions must be switched off to ensure reproducible builds see discussion 4494. Note you need to call to exclude both labels. See issue 2596 for more information. As Intel compilers use unsafe floating point optimization by default, the unit tests may fail. Use flag https://www.intel.com/content/www/us/en/docs/cpp-compiler/developer-guide-reference/2021-8/fp-model-fp.html then.