GPU Puzzles - by Sasha Rush - srushnlp !https://github.com/srush/GPU-Puzzles/raw/main/cuda.png GPU architectures are critical to machine learning, and seem to be becoming even more important every day. However, you can be an expert in machine learning without ever touching GPU code. It is hard to gain intuition working through abstractions. This notebook is an attempt to teach beginner GPU programming in a completely interactive fashion. Instead of providing text with concepts, it throws you right into coding and building GPU kernels. The exercises use NUMBA which directly maps Python code to CUDA kernels. It looks like Python but is basically identical to writing low-level CUDA code. In a few hours, I think you can go from basics to understanding the real algorithms that power 99% of deep learning today. If you do want to read the manual, it is here: NUMBA CUDA Guide I recommend doing these in Colab, as it is easy to get started. Be sure to make your own copy, turn on GPU mode in the settings , then set to , and then get to coding. !Open In Colabhttps://colab.research.google.com/github/srush/GPU-Puzzles/blob/main/GPUpuzzlers.ipynb If you are into this style of puzzle, also check out my Tensor Puzzles for PyTorch. Walkthrough Guide Puzzle 1: Map Implement a "kernel" GPU function that adds 10 to each position of vector and stores it in vector . You have 1 thread per position. Warning This code looks like Python but it is really CUDA! You cannot use standard python tools like list comprehensions or ask for Numpy properties like shape or size if you need the size, it is given as an argument. The puzzles only require doing simple operations, basically +, , simple array indexing, for loops, and if statements. You are allowed to use local variables. If you get an error it is probably because you did something fancy :. Tip: Think of the function as being run 1 time for each thread. The only difference is that changes each time. Map Score Max Per Thread: | Global Reads | Global Writes | Shared Reads | Shared Writes | | 0 | 0 | 0 | 0 | !svg Failed Tests. Yours: 0. 0. 0. 0. Spec : 10 11 12 13 Puzzle 2 - Zip Implement a kernel that adds together each position of and and stores it in . You have 1 thread per position. Zip Score Max Per Thread: | Global Reads | Global Writes | Shared Reads | Shared Writes | | 0 | 0 | 0 | 0 | !svg Failed Tests. Yours: 0. 0. 0. 0. Spec : 0 2 4 6 Puzzle 3 - Guards Implement a kernel that adds 10 to each position of and stores it in . You have more threads than positions. Guard Score Max Per Thread: | Global Reads | Global Writes | Shared Reads | Shared Writes | | 0 | 0 | 0 | 0 | !svg Failed Tests. Yours: 0. 0. 0. 0. Spec : 10 11 12 13 Puzzle 4 - Map 2D Implement a kernel that adds 10 to each position of and stores it in . Input is 2D and square. You have more threads than positions. Map 2D Score Max Per Thread: | Global Reads | Global Writes | Shared Reads | Shared Writes | | 0 | 0 | 0 | 0 | !svg Failed Tests. Yours: 0. 0. 0. 0. Spec : 10 11 12 13 Puzzle 5 - Broadcast Implement a kernel that adds and and stores it in . Inputs and are vectors. You have more threads than positions. Broadcast Score Max Per Thread: | Global Reads | Global Writes | Shared Reads | Shared Writes | | 0 | 0 | 0 | 0 | !svg Failed Tests. Yours: 0. 0. 0. 0. Spec : 0 1 1 2 Puzzle 6 - Blocks Implement a kernel that adds 10 to each position of and stores it in . You have fewer threads per block than the size of . Tip: A block is a group of threads. The number of threads per block is limited, but we can have many different blocks. Variable tells us what block we are in. Blocks Score Max Per Thread: | Global Reads | Global Writes | Shared Reads | Shared Writes | | 0 | 0 | 0 | 0 | !svg Failed Tests. Yours: 0. 0. 0. 0. 0. 0. 0. 0. 0. Spec : 10 11 12 13 14 15 16 17 18 Puzzle 7 - Blocks 2D Implement the same kernel in 2D. You have fewer threads per block than the size of in both directions. Blocks 2D Score Max Per Thread: | Global Reads | Global Writes | Shared Reads | Shared Writes | | 0 | 0 | 0 | 0 | !svg Failed Tests. Yours: 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. Spec : 11. 11. 11. 11. 11. 11. 11. 11. 11. 11. 11. 11. 11. 11. 11. 11. 11. 11. 11. 11. 11. 11. 11. 11. 11. Puzzle 8 - Shared Implement a kernel that adds 10 to each position of and stores it in . You have fewer threads per block than the size of . Warning: Each block can only have a constant amount of shared memory that threads in that block can read and write to. This needs to be a literal python constant not a variable. After writing to shared memory you need to call to ensure that threads do not cross. This example does not really need shared memory or syncthreads, but it is a demo. Shared Score Max Per Thread: | Global Reads | Global Writes | Shared Reads | Shared Writes | | 1 | 0 | 0 | 1 | !svg Failed Tests. Yours: 0. 0. 0. 0. 0. 0. 0. 0. Spec : 11. 11. 11. 11. 11. 11. 11. 11. Puzzle 9 - Pooling Implement a kernel that sums together the last 3 position of and stores it in . You have 1 thread per position. You only need 1 global read and 1 global write per thread. Tip: Remember to be careful about syncing. Pooling Score Max Per Thread: | Global Reads | Global Writes | Shared Reads | Shared Writes | | 0 | 0 | 0 | 0 | !svg Failed Tests. Yours: 0. 0. 0. 0. 0. 0. 0. 0. Spec : 0. 1. 3. 6. 9. 12. 15. 18. Puzzle 10 - Dot Product Implement a kernel that computes the dot-product of and and stores it in . You have 1 thread per position. You only need 2 global reads and 1 global write per thread. Note: For this problem you don't need to worry about number of shared reads. We will handle that challenge later. Dot Score Max Per Thread: | Global Reads | Global Writes | Shared Reads | Shared Writes | | 0 | 0 | 0 | 0 | !svg Failed Tests. Yours: 0. Spec : 140 Puzzle 11 - 1D Convolution Implement a kernel that computes a 1D convolution between and and stores it in . You need to handle the general case. You only need 2 global reads and 1 global write per thread. 1D Conv Simple Score Max Per Thread: | Global Reads | Global Writes | Shared Reads | Shared Writes | | 0 | 0 | 0 | 0 | !svg Failed Tests. Yours: 0. 0. 0. 0. 0. 0. Spec : 5. 8. 11. 14. 5. 0. Test 2 1D Conv Full Score Max Per Thread: | Global Reads | Global Writes | Shared Reads | Shared Writes | | 0 | 0 | 0 | 0 | !svg Failed Tests. Yours: 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. Spec : 14. 20. 26. 32. 38. 44. 50. 56. 62. 68. 74. 80. 41. 14. 0. Puzzle 12 - Prefix Sum Implement a kernel that computes a sum over and stores it in . If the size of is greater than the block size, only store the sum of each block. We will do this using the parallel prefix sum algorithm in shared memory. That is, each step of the algorithm should sum together half the remaining numbers. Follow this diagram: !https://user-images.githubusercontent.com/35882/178757889-1c269623-93af-4a2e-a7e9-22cd55a42e38.png Sum Simple Score Max Per Thread: | Global Reads | Global Writes | Shared Reads | Shared Writes | | 0 | 0 | 0 | 0 | !svg Failed Tests. Yours: 0. Spec : 28. Test 2 Sum Full Score Max Per Thread: | Global Reads | Global Writes | Shared Reads | Shared Writes | | 0 | 0 | 0 | 0 | !svg Failed Tests. Yours: 0. 0. Spec : 28. 77. Puzzle 13 - Axis Sum Implement a kernel that computes a sum over each column of and stores it in . Axis Sum Score Max Per Thread: | Global Reads | Global Writes | Shared Reads | Shared Writes | | 0 | 0 | 0 | 0 | !svg Failed Tests. Yours: 0. 0. 0. 0. Spec : 15. 51. 87. 123. Puzzle 14 - Matrix Multiply! Implement a kernel that multiplies square matrices and and stores the result in . Tip: The most efficient algorithm here will copy a block into shared memory before computing each of the individual row-column dot products. This is easy to do if the matrix fits in shared memory. Do that case first. Then update your code to compute a partial dot-product and iteratively move the part you copied into shared memory. You should be able to do the hard case in 6 global reads. Matmul Simple Score Max Per Thread: | Global Reads | Global Writes | Shared Reads | Shared Writes | | 0 | 0 | 0 | 0 | !svg Failed Tests. Yours: 0. 0. 0. 0. Spec : 1 3 3 13 Test 2 Matmul Full Score Max Per Thread: | Global Reads | Global Writes | Shared Reads | Shared Writes | | 0 | 0 | 0 | 0 | !svg Failed Tests. Yours: 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. Spec : 140 364 588 812 1036 1260 1484 1708 364 1100 1836 2572 3308 4044 4780 5516 588 1836 3084 4332 5580 6828 8076 9324 812 2572 4332 6092 7852 9612 11372 13132 1036 3308 5580 7852 10124 12396 14668 16940 1260 4044 6828 9612 12396 15180 17964 20748 1484 4780 8076 11372 14668 17964 21260 24556 1708 5516 9324 13132 16940 20748 24556 28364