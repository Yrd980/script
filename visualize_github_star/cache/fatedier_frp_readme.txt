frp !Build Statushttps://circleci.com/gh/fatedier/frp !GitHub releasehttps://github.com/fatedier/frp/releases !Go Report Cardhttps://goreportcard.com/report/github.com/fatedier/frp !GitHub Releases Statshttps://somsubhra.github.io/github-release-stats/?username=fatedier&repository=frp README | 中文文档 Sponsors frp is an open source project with its ongoing development made possible entirely by the support of our awesome sponsors. If you'd like to join them, please consider sponsoring frp's development. <h3 align="center">Gold Sponsors</h3> <!--gold sponsors start--> <p align="center"> <a href="https://go.warp.dev/frp" target="blank"> <img width="360px" src="https://raw.githubusercontent.com/warpdotdev/brand-assets/refs/heads/main/Github/Sponsor/Warp-Github-LG-01.png"> <br> <b>Warp, the intelligent terminal</b> <br> <sub>Available for macOS, Linux and Windows</sub> </a> </p> <p align="center"> <a href="https://jb.gg/frp" target="blank"> <img width="420px" src="https://raw.githubusercontent.com/fatedier/frp/dev/doc/pic/sponsorjetbrains.jpg"> <br> <b>The complete IDE crafted for professional Go developers</b> </a> </p> <p align="center"> <a href="https://github.com/daytonaio/daytona" target="blank"> <img width="420px" src="https://raw.githubusercontent.com/fatedier/frp/dev/doc/pic/sponsordaytona.png"> <br> <b>Secure and Elastic Infrastructure for Running Your AI-Generated Code</b> </a> </p> <p align="center"> <a href="https://github.com/beclab/Olares" target="blank"> <img width="420px" src="https://raw.githubusercontent.com/fatedier/frp/dev/doc/pic/sponsorolares.jpeg"> <br> <b>The sovereign cloud that puts you in control</b> <br> <sub>An open source, self-hosted alternative to public clouds, built for data ownership and privacy</sub> </a> </p> <!--gold sponsors end--> What is frp? frp is a fast reverse proxy that allows you to expose a local server located behind a NAT or firewall to the Internet. It currently supports TCP and UDP, as well as HTTP and HTTPS protocols, enabling requests to be forwarded to internal services via domain name. frp also offers a P2P connect mode. Table of Contents <!-- vim-markdown-toc GFM --> Development Status About V2 Architecture Example Usage Access your computer in a LAN network via SSH Multiple SSH services sharing the same port Accessing Internal Web Services with Custom Domains in LAN Forward DNS query requests Forward Unix Domain Socket Expose a simple HTTP file server Enable HTTPS for a local HTTPS service Expose your service privately P2P Mode Features Configuration Files Using Environment Variables Split Configures Into Different Files Server Dashboard Client Admin UI Monitor Prometheus Authenticating the Client Token Authentication OIDC Authentication Encryption and Compression TLS Hot-Reloading frpc configuration Get proxy status from client Only allowing certain ports on the server Port Reuse Bandwidth Limit For Each Proxy TCP Stream Multiplexing Support KCP Protocol Support QUIC Protocol Connection Pooling Load balancing Service Health Check Rewriting the HTTP Host Header Setting other HTTP Headers Get Real IP HTTP X-Forwarded-For Proxy Protocol Require HTTP Basic Auth Password for Web Services Custom Subdomain Names URL Routing TCP Port Multiplexing Connecting to frps via PROXY Port range mapping Client Plugins Server Manage Plugins SSH Tunnel Gateway Virtual Network VirtualNet Feature Gates Available Feature Gates Enabling Feature Gates Feature Lifecycle Related Projects Contributing Donation GitHub Sponsors PayPal <!-- vim-markdown-toc --> Development Status frp is currently under development. You can try the latest release version in the branch, or use the branch to access the version currently in development. We are currently working on version 2 and attempting to perform some code refactoring and improvements. However, please note that it will not be compatible with version 1. We will transition from version 0 to version 1 at the appropriate time and will only accept bug fixes and improvements, rather than big feature requests. About V2 The complexity and difficulty of the v2 version are much higher than anticipated. I can only work on its development during fragmented time periods, and the constant interruptions disrupt productivity significantly. Given this situation, we will continue to optimize and iterate on the current version until we have more free time to proceed with the major version overhaul. The concept behind v2 is based on my years of experience and reflection in the cloud-native domain, particularly in K8s and ServiceMesh. Its core is a modernized four-layer and seven-layer proxy, similar to envoy. This proxy itself is highly scalable, not only capable of implementing the functionality of intranet penetration but also applicable to various other domains. Building upon this highly scalable core, we aim to implement all the capabilities of frp v1 while also addressing the functionalities that were previously unachievable or difficult to implement in an elegant manner. Furthermore, we will maintain efficient development and iteration capabilities. In addition, I envision frp itself becoming a highly extensible system and platform, similar to how we can provide a range of extension capabilities based on K8s. In K8s, we can customize development according to enterprise needs, utilizing features such as CRD, controller mode, webhook, CSI, and CNI. In frp v1, we introduced the concept of server plugins, which implemented some basic extensibility. However, it relies on a simple HTTP protocol and requires users to start independent processes and manage them on their own. This approach is far from flexible and convenient, and real-world demands vary greatly. It is unrealistic to expect a non-profit open-source project maintained by a few individuals to meet everyone's needs. Finally, we acknowledge that the current design of modules such as configuration management, permission verification, certificate management, and API management is not modern enough. While we may carry out some optimizations in the v1 version, ensuring compatibility remains a challenging issue that requires a considerable amount of effort to address. We sincerely appreciate your support for frp. Architecture !architecture Example Usage To begin, download the latest program for your operating system and architecture from the Release page. Next, place the binary and server configuration file on Server A, which has a public IP address. Finally, place the binary and client configuration file on Server B, which is located on a LAN that cannot be directly accessed from the public internet. Some antiviruses improperly mark frpc as malware and delete it. This is due to frp being a networking tool capable of creating reverse proxies. Antiviruses sometimes flag reverse proxies due to their ability to bypass firewall port restrictions. If you are using antivirus, then you may need to whitelist/exclude frpc in your antivirus settings to avoid accidental quarantine/deletion. See issue 3637 for more details. Access your computer in a LAN network via SSH 1. Modify on server A by setting the for frp clients to connect to: 2. Start on server A: 3. Modify on server B and set the field to the public IP address of your frps server: Note that the listened on the client and exposed on the server are used for traffic going in and out of the frp system, while the is used for communication between frps and frpc. 4. Start on server B: 5. To access server B from another machine through server A via SSH assuming the username is , use the following command: Multiple SSH services sharing the same port This example implements multiple SSH services exposed through the same port using a proxy of type tcpmux. Similarly, as long as the client supports the HTTP Connect proxy connection method, port reuse can be achieved in this way. 1. Deploy frps on a machine with a public IP and modify the frps.toml file. Here is a simplified configuration: 2. Deploy frpc on the internal machine A with the following configuration: 3. Deploy another frpc on the internal machine B with the following configuration: 4. To access internal machine A using SSH ProxyCommand, assuming the username is "test": 5. To access internal machine B, the only difference is the domain name, assuming the username is "test": Accessing Internal Web Services with Custom Domains in LAN Sometimes we need to expose a local web service behind a NAT network to others for testing purposes with our own domain name. Unfortunately, we cannot resolve a domain name to a local IP. However, we can use frp to expose an HTTPS service. 1. Modify and set the HTTP port for vhost to 8080: If you want to configure an https proxy, you need to set up the . 2. Start : 3. Modify and set to the IP address of the remote frps server. Specify the of your web service: 4. Start : 5. Map the A record of to either the public IP of the remote frps server or a CNAME record pointing to your original domain. 6. Visit your local web service using url . Forward DNS query requests 1. Modify : 2. Start : 3. Modify and set to the IP address of the remote frps server. Forward DNS query requests to the Google Public DNS server : 4. Start frpc: 5. Test DNS resolution using the command: Forward Unix Domain Socket Expose a Unix domain socket e.g. the Docker daemon socket as TCP. Configure as above. 1. Start with the following configuration: 2. Test the configuration by getting the docker version using : Expose a simple HTTP file server Expose a simple HTTP file server to access files stored in the LAN from the public Internet. Configure as described above, then: 1. Start with the following configuration: 2. Visit from your browser and specify correct username and password to view files in on the machine. Enable HTTPS for a local HTTPS service You may substitute for the plugin, and point the to a HTTPS endpoint. 1. Start with the following configuration: 2. Visit . Expose your service privately To mitigate risks associated with exposing certain services directly to the public network, STCP Secret TCP mode requires a preshared key to be used for access to the service from other clients. Configure same as above. 1. Start on machine B with the following config. This example is for exposing the SSH service port 22, and note the field for the preshared key, and that the field is removed here: 2. Start another typically on another machine C with the following config to access the SSH service with a security key field: 3. On machine C, connect to SSH on machine B, using this command: P2P Mode xtcp is designed to transmit large amounts of data directly between clients. A frps server is still needed, as P2P here only refers to the actual data transmission. Note that it may not work with all types of NAT devices. You might want to fallback to stcp if xtcp doesn't work. 1. Start on machine B, and expose the SSH port. Note that the field is removed: 2. Start another typically on another machine C with the configuration to connect to SSH using P2P mode: 3. On machine C, connect to SSH on machine B, using this command: Features Configuration Files Since v0.52.0, we support TOML, YAML, and JSON for configuration. Please note that INI is deprecated and will be removed in future releases. New features will only be available in TOML, YAML, or JSON. Users wanting these new features should switch their configuration format accordingly. Read the full example configuration files to find out even more features not described here. Examples use TOML format, but you can still use YAML or JSON. These configuration files is for reference only. Please do not use this configuration directly to run the program as it may have various issues. Full configuration file for frps Server Full configuration file for frpc Client Using Environment Variables Environment variables can be referenced in the configuration file, using Go's standard format: With the config above, variables can be passed into program like this: will render configuration file template using OS environment variables. Remember to prefix your reference with . Split Configures Into Different Files You can split multiple proxy configs into different files and include them in the main file. Server Dashboard Check frp's status and proxies' statistics information by Dashboard. Configure a port for dashboard to enable this feature: Then visit to see the dashboard, with username and password both being . Additionally, you can use HTTPS port by using your domains wildcard or normal SSL certificate: Then visit to see the dashboard in secure HTTPS connection, with username and password both being . !dashboard Client Admin UI The Client Admin UI helps you check and manage frpc's configuration. Configure an address for admin UI to enable this feature: Then visit to see admin UI, with username and password both being . Monitor When web server is enabled, frps will save monitor data in cache for 7 days. It will be cleared after process restart. Prometheus is also supported. Prometheus Enable dashboard first, then configure in . will provide prometheus monitor data. Authenticating the Client There are 2 authentication methods to authenticate frpc with frps. You can decide which one to use by configuring in and , the default one is token. Configuring will use the configured authentication method to add and validate authentication on every heartbeat between frpc and frps. Configuring will do the same for every new work connection between frpc and frps. Token Authentication When specifying in and - token based authentication will be used. Make sure to specify the same in and for frpc to pass frps validation Token Source frp supports reading authentication tokens from external sources using the configuration. Currently, file-based token source is supported. File-based token source: The token will be read from the specified file at startup. This is useful for scenarios where tokens are managed by external systems or need to be kept separate from configuration files for security reasons. OIDC Authentication When specifying in and - OIDC based authentication will be used. OIDC stands for OpenID Connect, and the flow used is called Client Credentials Grant. To use this authentication type - configure and as follows: Encryption and Compression The features are off by default. You can turn on encryption and/or compression: TLS Since v0.50.0, the default value of and has been changed to true, and tls is enabled by default. For port multiplexing, frp sends a first byte to dial a TLS connection. This only takes effect when you set to false. To enforce to only accept TLS connections - configure in . This is optional. TLS settings: TLS settings: You will need a root CA cert and at least one SSL/TLS certificate. It can be self-signed or regular such as Let's Encrypt or another SSL/TLS certificate provider. If you using via IP address and not hostname, make sure to set the appropriate IP address in the Subject Alternative Name SAN area when generating SSL/TLS Certificates. Given an example: Prepare openssl config file. It exists at in Linux System and in MacOS, and you can copy it to current path, like . If not, you can build it by yourself, like: build ca certificates: build frps certificates: build frpc certificates： Hot-Reloading frpc configuration The fields are required for enabling HTTP API: Then run command and wait for about 10 seconds to let create or update or remove proxies. Note that global client parameters won't be modified except 'start'. You can run command before reloading to check if there are config errors. Get proxy status from client Use to get status of all proxies. The fields are required for enabling HTTP API. Only allowing certain ports on the server in is used to avoid abuse of ports: Port Reuse and in frps can use same port with . frps will detect the connection's protocol and handle it correspondingly. What you need to pay attention to is that if you want to configure and to the same port, you need to first set to false. We would like to try to allow multiple proxies bind a same remote port with different protocols in the future. Bandwidth Limit For Each Proxy Set in each proxy's configure to enable this feature. Supported units are and . Set to or to limit bandwidth on the client or server side. Default is . TCP Stream Multiplexing frp supports tcp stream multiplexing since v0.10.0 like HTTP2 Multiplexing, in which case all logic connections to the same frpc are multiplexed into the same TCP connection. You can disable this feature by modify and : Support KCP Protocol KCP is a fast and reliable protocol that can achieve the transmission effect of a reduction of the average latency by 30% to 40% and reduction of the maximum delay by a factor of three, at the cost of 10% to 20% more bandwidth wasted than TCP. KCP mode uses UDP as the underlying transport. Using KCP in frp: 1. Enable KCP in frps: The number can be the same number as , since field specifies a TCP port. 2. Configure to use KCP to connect to frps: Support QUIC Protocol QUIC is a new multiplexed transport built on top of UDP. Using QUIC in frp: 1. Enable QUIC in frps: The number can be the same number as , since field specifies a TCP port. 2. Configure to use QUIC to connect to frps: Connection Pooling By default, frps creates a new frpc connection to the backend service upon a user request. With connection pooling, frps keeps a certain number of pre-established connections, reducing the time needed to establish a connection. This feature is suitable for a large number of short connections. 1. Configure the limit of pool count each proxy can use in : 2. Enable and specify the number of connection pool: Load balancing Load balancing is supported by . This feature is only available for types , , now. is used for authentication. Connections to port 80 will be dispatched to proxies in the same group randomly. For type , in the same group should be the same. For type , , , should be the same. Service Health Check Health check feature can help you achieve high availability with load balancing. Add or to enable health check. With health check type tcp, the service port will be pinged TCPing: With health check type http, an HTTP request will be sent to the service and an HTTP 2xx OK response is expected: Rewriting the HTTP Host Header By default frp does not modify the tunneled HTTP requests at all as it's a byte-for-byte copy. However, speaking of web servers and HTTP requests, your web server might rely on the HTTP header to determine the website to be accessed. frp can rewrite the header when forwarding the HTTP requests, with the field: The HTTP request will have the header rewritten to when it reaches the actual web server, although the request from the browser probably has . Setting other HTTP Headers Similar to , You can override other HTTP request and response headers with proxy type . In this example, it will set header in the HTTP request and in the HTTP response. Get Real IP HTTP X-Forwarded-For This feature is for proxies or proxies with the and plugins enabled. You can get user's real IP from HTTP request headers . Proxy Protocol frp supports Proxy Protocol to send user's real IP to local services. Here is an example for https service: You can enable Proxy Protocol support in nginx to expose user's real IP in HTTP header , and then read header in your web service for the real IP. Require HTTP Basic Auth Password for Web Services Anyone who can guess your tunnel URL can access your local web server unless you protect it with a password. This enforces HTTP Basic Auth on all requests with the username and password specified in frpc's configure file. It can only be enabled when proxy type is http. Visit in the browser and now you are prompted to enter the username and password. Custom Subdomain Names It is convenient to use configure for http and https types when many people share one frps server. Resolve to the frps server's IP. This is usually called a Wildcard DNS record. Now you can visit your web service on . Note that if is not empty, should not be the subdomain of . URL Routing frp supports forwarding HTTP requests to different backend web services by url routing. specifies the prefix of URL used for routing. frps first searches for the most specific prefix location given by literal strings regardless of the listed order. HTTP requests with URL prefix or will be forwarded to web02 and other requests to web01. TCP Port Multiplexing frp supports receiving TCP sockets directed to different proxies on a single port on frps, similar to and . The only supported TCP port multiplexing method available at the moment is - HTTP CONNECT tunnel. When setting to anything other than 0 in frps, frps will listen on this port for HTTP CONNECT requests. The host of the HTTP CONNECT request will be used to match the proxy in frps. Proxy hosts can be configured in frpc by configuring and / or under proxies, when . For example: In the above configuration - frps can be contacted on port 1337 with a HTTP CONNECT header such as: and the connection will be routed to . Connecting to frps via PROXY frpc can connect to frps through proxy if you set OS environment variable , or if is set in frpc.toml file. It only works when protocol is tcp. Port range mapping Added in v0.56.0 We can use the range syntax of Go template combined with the built-in function to achieve port range mapping. The following example, when run, will create 8 proxies named , each mapping the remote port to the local port. Client Plugins frpc only forwards requests to local TCP or UDP ports by default. Plugins are used for providing rich features. There are built-in plugins such as , , , , , , and you can see example usage. Using plugin httpproxy: and are configuration parameters used in plugin. Server Manage Plugins Read the document. Find more plugins in gofrp/plugin. SSH Tunnel Gateway added in v0.53.0 frp supports listening to an SSH port on the frps side and achieves TCP protocol proxying through the SSH -R protocol, without relying on frpc. When running , a private key file named will be automatically created in the current working directory. This generated private key file will be used by the SSH server in frps. Executing the command sets up a proxy on frps that forwards the local 8080 service to the port 9090. This is equivalent to: Please refer to this document for more information. Virtual Network VirtualNet Alpha feature added in v0.62.0 The VirtualNet feature enables frp to create and manage virtual network connections between clients and visitors through a TUN interface. This allows for IP-level routing between machines, extending frp beyond simple port forwarding to support full network connectivity. For detailed information about configuration and usage, please refer to the VirtualNet documentation. Feature Gates frp supports feature gates to enable or disable experimental features. This allows users to try out new features before they're considered stable. Available Feature Gates | Name | Stage | Default | Description | |------|-------|---------|-------------| | VirtualNet | ALPHA | false | Virtual network capabilities for frp | Enabling Feature Gates To enable an experimental feature, add the feature gate to your configuration: Feature Lifecycle Features typically go through three stages: 1. ALPHA: Disabled by default, may be unstable 2. BETA: May be enabled by default, more stable but still evolving 3. GA Generally Available: Enabled by default, ready for production use Related Projects gofrp/plugin - A repository for frp plugins that contains a variety of plugins implemented based on the frp extension mechanism, meeting the customization needs of different scenarios. gofrp/tiny-frpc - A lightweight version of the frp client around 3.5MB at minimum implemented using the ssh protocol, supporting some of the most commonly used features, suitable for devices with limited resources. Contributing Interested in getting involved? We would like to help you! Take a look at our issues list and consider sending a Pull Request to dev branch. If you want to add a new feature, please create an issue first to describe the new feature, as well as the implementation approach. Once a proposal is accepted, create an implementation of the new features and submit it as a pull request. Sorry for my poor English. Improvements for this document are welcome, even some typo fixes. If you have great ideas, send an email to fatedier@gmail.com. Note: We prefer you to give your advise in issues, so others with a same question can search it quickly and we don't need to answer them repeatedly. Donation If frp helps you a lot, you can support us by: GitHub Sponsors Support us by Github Sponsors. You can have your company's logo placed on README file of this project. PayPal Donate money by PayPal to my account fatedier@gmail.com.