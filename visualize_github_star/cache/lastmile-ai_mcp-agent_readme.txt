<p align="center"> <a href="https://docs.mcp-agent.com"><img src="https://github.com/user-attachments/assets/c8d059e5-bd56-4ea2-a72d-807fb4897bde" alt="Logo" width="300" /></a> </p> <p align="center"> <em>Build effective agents with Model Context Protocol using simple, composable patterns.</em> <p align="center"> <a href="https://github.com/lastmile-ai/mcp-agent/tree/main/examples" target="blank"><strong>Examples</strong></a> | <a href="https://www.anthropic.com/research/building-effective-agents" target="blank"><strong>Building Effective Agents</strong></a> | <a href="https://modelcontextprotocol.io/introduction" target="blank"><strong>MCP</strong></a> </p> <p align="center"> <a href="https://docs.mcp-agent.com"><img src="https://img.shields.io/badge/docs-8F?style=flat&link=https%3A%2F%2Fdocs.mcp-agent.com%2F" /><a/> <a href="https://pypi.org/project/mcp-agent/"><img src="https://img.shields.io/pypi/v/mcp-agent?color=%2334D058&label=pypi" /></a> <a href="https://github.com/lastmile-ai/mcp-agent/issues"><img src="https://img.shields.io/github/issues-raw/lastmile-ai/mcp-agent" /></a> <img alt="Pepy Total Downloads" src="https://img.shields.io/pepy/dt/mcp-agent?label=pypi%20%7C%20downloads"/> <a href="https://github.com/lastmile-ai/mcp-agent/blob/main/LICENSE"><img src="https://img.shields.io/badge/License-Apache2.0-blue.svg"/></a> <a href="https://lmai.link/discord/mcp-agent"><img src="https://img.shields.io/badge/Discord-%235865F2.svg?logo=discord&logoColor=white" alt="discord"/></a> </p> <p align="center"> <a href="https://trendshift.io/repositories/13216" target="blank"><img src="https://trendshift.io/api/badge/repositories/13216" alt="lastmile-ai%2Fmcp-agent | Trendshift" style="width: 250px; height: 55px;" width="250" height="55"/></a> </p> Overview is a simple, composable framework to build agents using Model Context Protocol. Inspiration: Anthropic announced 2 foundational updates for AI application developers: 1. Model Context Protocol - a standardized interface to let any software be accessible to AI assistants via MCP servers. 2. Building Effective Agents - a seminal writeup on simple, composable patterns for building production-ready AI agents. puts these two foundational pieces into an AI application framework: 1. It handles the pesky business of managing the lifecycle of MCP server connections so you don't have to. 2. It implements every pattern described in Building Effective Agents, and does so in a composable way, allowing you to chain these patterns together. 3. Bonus: It implements OpenAI's Swarm pattern for multi-agent orchestration, but in a model-agnostic way. Altogether, this is the simplest and easiest way to build robust agent applications. Much like MCP, this project is in early development. We welcome all kinds of contributions, feedback and your help in growing this to become a new standard. Get Started We recommend using uv to manage your Python projects: Alternatively: Quickstart > !TIP > The /examples directory has several example applications to get started with. > To run an example, clone this repo, then: > > Here is a basic "finder" agent that uses the fetch and filesystem servers to look up a file, read a blog and write a tweet. Example link: <details open> <summary>finderagent.py</summary> </details> <details> <summary>mcpagent.config.yaml</summary> </details> <details> <summary>Agent output</summary> <img width="2398" alt="Image" src="https://github.com/user-attachments/assets/eaa60fdf-bcc6-460b-926e-6fa8534e9089" /> </details> Table of Contents - Why use mcp-agent? - Example Applications - Claude Desktop - Streamlit - Gmail Agent - RAG - Marimo - Python - Swarm CLI - Core Concepts - Workflows Patterns - Augmented LLM - Parallel - Router - Intent-Classifier - Orchestrator-Workers - Evaluator-Optimizer - OpenAI Swarm - Advanced - Composing multiple workflows - Signaling and Human input - App Config - MCP Server Management - Contributing - Roadmap - FAQs Why use ? There are too many AI frameworks out there already. But is the only one that is purpose-built for a shared protocol - MCP. It is also the most lightweight, and is closer to an agent pattern library than a framework. As more services become MCP-aware, you can use mcp-agent to build robust and controllable AI agents that can leverage those services out-of-the-box. Examples Before we go into the core concepts of mcp-agent, let's show what you can build with it. In short, you can build any kind of AI application with mcp-agent: multi-agent collaborative workflows, human-in-the-loop workflows, RAG pipelines and more. Claude Desktop You can integrate mcp-agent apps into MCP clients like Claude Desktop. mcp-agent server This app wraps an mcp-agent application inside an MCP server, and exposes that server to Claude Desktop. The app exposes agents and workflows that Claude Desktop can invoke to service of the user's request. https://github.com/user-attachments/assets/7807cffd-dba7-4f0c-9c70-9482fd7e0699 This demo shows a multi-agent evaluation task where each agent evaluates aspects of an input poem, and then an aggregator summarizes their findings into a final response. Details: Starting from a user's request over text, the application: - dynamically defines agents to do the job - uses the appropriate workflow to orchestrate those agents in this case the Parallel workflow Link to code: examples/basic/mcpserveraggregator > !NOTE > Huge thanks to Jerron Lim @StreetLamb > for developing and contributing this example! Streamlit You can deploy mcp-agent apps using Streamlit. Gmail agent This app is able to perform read and write actions on gmail using text prompts -- i.e. read, delete, send emails, mark as read/unread, etc. It uses an MCP server for Gmail. https://github.com/user-attachments/assets/54899cac-de24-4102-bd7e-4b2022c956e3 Link to code: gmail-mcp-server > !NOTE > Huge thanks to Jason Summer @jasonsum > for developing and contributing this example! Simple RAG Chatbot This app uses a Qdrant vector database via an MCP server to do Q&A over a corpus of text. https://github.com/user-attachments/assets/f4dcd227-cae9-4a59-aa9e-0eceeb4acaf4 Link to code: examples/usecases/streamlitmcpragagent > !NOTE > Huge thanks to Jerron Lim @StreetLamb > for developing and contributing this example! Marimo Marimo is a reactive Python notebook that replaces Jupyter and Streamlit. Here's the "file finder" agent from Quickstart implemented in Marimo: <img src="https://github.com/user-attachments/assets/139a95a5-e3ac-4ea7-9c8f-bad6577e8597" width="400"/> Link to code: examples/usecases/marimomcpbasicagent > !NOTE > Huge thanks to Akshay Agrawal @akshayka > for developing and contributing this example! Python You can write mcp-agent apps as Python scripts or Jupyter notebooks. Swarm This example demonstrates a multi-agent setup for handling different customer service requests in an airline context using the Swarm workflow pattern. The agents can triage requests, handle flight modifications, cancellations, and lost baggage cases. https://github.com/user-attachments/assets/b314d75d-7945-4de6-965b-7f21eb14a8bd Link to code: examples/workflows/workflowswarm Core Components The following are the building blocks of the mcp-agent framework: - MCPApp: global state and app configuration - MCP server management: ./src/mcpagent/mcp/genclient.py and ./src/mcpagent/mcp/mcpconnectionmanager.py to easily connect to MCP servers. - Agent: An Agent is an entity that has access to a set of MCP servers and exposes them to an LLM as tool calls. It has a name and purpose instruction. - AugmentedLLM: An LLM that is enhanced with tools provided from a collection of MCP servers. Every Workflow pattern described below is an itself, allowing you to compose and chain them together. Everything in the framework is a derivative of these core capabilities. Workflows mcp-agent provides implementations for every pattern in Anthropic‚Äôs Building Effective Agents, as well as the OpenAI Swarm pattern. Each pattern is model-agnostic, and exposed as an , making everything very composable. AugmentedLLM AugmentedLLM is an LLM that has access to MCP servers and functions via Agents. LLM providers implement the AugmentedLLM interface to expose 3 functions: - : Generate messages given a prompt, possibly over multiple iterations and making tool calls as needed. - : Calls and returns result as a string output. - : Uses Instructor to return the generated result as a Pydantic model. Additionally, has memory, to keep track of long or short-term history. <details> <summary>Example</summary> </details> Parallel !Parallel workflow Image credit: Anthropic Fan-out tasks to multiple sub-agents and fan-in the results. Each subtask is an AugmentedLLM, as is the overall Parallel workflow, meaning each subtask can optionally be a more complex workflow itself. > !NOTE > > Link to full example <details> <summary>Example</summary> </details> Router !Router workflow Image credit: Anthropic Given an input, route to the most relevant categories. A category can be an Agent, an MCP server or a regular function. mcp-agent provides several router implementations, including: - src/mcpagent/workflows/router/routerembedding.py: uses embedding models for classification - src/mcpagent/workflows/router/routerllm.py: uses LLMs for classification > !NOTE > > Link to full example <details> <summary>Example</summary> </details> IntentClassifier A close sibling of Router, the Intent Classifier pattern identifies the Intents that most closely match a given input. Just like a Router, mcp-agent provides both an embedding and LLM-based intent classifier. Evaluator-Optimizer !Evaluator-optimizer workflow Image credit: Anthropic One LLM the ‚Äúoptimizer‚Äù refines a response, another the ‚Äúevaluator‚Äù critiques it until a response exceeds a quality criteria. > !NOTE > > Link to full example <details> <summary>Example</summary> </details> Orchestrator-workers !Orchestrator workflow Image credit: Anthropic A higher-level LLM generates a plan, then assigns them to sub-agents, and synthesizes the results. The Orchestrator workflow automatically parallelizes steps that can be done in parallel, and blocks on dependencies. > !NOTE > > Link to full example <details> <summary>Example</summary> </details> Swarm OpenAI has an experimental multi-agent pattern called Swarm, which we provide a model-agnostic reference implementation for in mcp-agent. <img src="https://github.com/openai/swarm/blob/main/assets/swarmdiagram.png?raw=true" width=500 /> The mcp-agent Swarm pattern works seamlessly with MCP servers, and is exposed as an , allowing for composability with other patterns above. > !NOTE > > Link to full example <details> <summary>Example</summary> </details> Advanced Composability An example of composability is using an Evaluator-Optimizer workflow as the planner LLM inside the Orchestrator workflow. Generating a high-quality plan to execute is important for robust behavior, and an evaluator-optimizer can help ensure that. Doing so is seamless in mcp-agent, because each workflow is implemented as an . <details> <summary>Example</summary> </details> Signaling and Human Input Signaling: The framework can pause/resume tasks. The agent or LLM might ‚Äúsignal‚Äù that it needs user input, so the workflow awaits. A developer may signal during a workflow to seek approval or review before continuing with a workflow. Human Input: If an Agent has a , the LLM can call a tool to request user input mid-workflow. <details> <summary>Example</summary> The Swarm example shows this in action. </details> App Config Create an /schema/mcp-agent.config.schema.json and a gitignored ./examples/basic/mcpbasicagent/mcpagent.secrets.yaml.example to define MCP app configuration. This controls logging, execution, LLM provider APIs, and MCP server configuration. MCP server management mcp-agent makes it trivial to connect to MCP servers. Create an /schema/mcp-agent.config.schema.json to define server configuration under the section: src/mcpagent/mcp/genclient.py Manage the lifecycle of an MCP server within an async context manager: The genclient function makes it easy to spin up connections to MCP servers. Persistent server connections In many cases, you want an MCP server to stay online for persistent use e.g. in a multi-step tool use workflow. For persistent connections, use: - <src/mcpagent/mcp/genclient.py> and src/mcpagent/mcp/genclient.py - src/mcpagent/mcp/mcpconnectionmanager.py For even more fine-grained control over server connections, you can use the MCPConnectionManager. <details> <summary>Example</summary> </details> MCP Server Aggregator src/mcpagent/mcp/mcpaggregator.py acts as a "server-of-servers". It provides a single MCP server interface for interacting with multiple MCP servers. This allows you to expose tools from multiple servers to LLM applications. <details> <summary>Example</summary> </details> Contributing We welcome any and all kinds of contributions. Please see the CONTRIBUTING guidelines to get started. Special Mentions There have already been incredible community contributors who are driving this project forward: - Shaun Smith @evalstate -- who has been leading the charge on countless complex improvements, both to and generally to the MCP ecosystem. - Jerron Lim @StreetLamb -- who has contributed countless hours and excellent examples, and great ideas to the project. - Jason Summer @jasonsum -- for identifying several issues and adapting his Gmail MCP server to work with mcp-agent Roadmap We will be adding a detailed roadmap ideally driven by your feedback. The current set of priorities include: - Durable Execution -- allow workflows to pause/resume and serialize state so they can be replayed or be paused indefinitely. We are working on integrating Temporal for this purpose. - Memory -- adding support for long-term memory - Streaming -- Support streaming listeners for iterative progress - Additional MCP capabilities -- Expand beyond tool calls to support: - Resources - Prompts - Notifications FAQs What are the core benefits of using mcp-agent? mcp-agent provides a streamlined approach to building AI agents using capabilities exposed by MCP Model Context Protocol servers. MCP is quite low-level, and this framework handles the mechanics of connecting to servers, working with LLMs, handling external signals like human input and supporting persistent state via durable execution. That lets you, the developer, focus on the core business logic of your AI application. Core benefits: - ü§ù Interoperability: ensures that any tool exposed by any number of MCP servers can seamlessly plug in to your agents. - ‚õìÔ∏è Composability & Customizability: Implements well-defined workflows, but in a composable way that enables compound workflows, and allows full customization across model provider, logging, orchestrator, etc. - üíª Programmatic control flow: Keeps things simple as developers just write code instead of thinking in graphs, nodes and edges. For branching logic, you write statements. For cycles, use loops. - üñêÔ∏è Human Input & Signals: Supports pausing workflows for external signals, such as human input, which are exposed as tool calls an Agent can make. Do you need an MCP client to use mcp-agent? No, you can use mcp-agent anywhere, since it handles MCPClient creation for you. This allows you to leverage MCP servers outside of MCP hosts like Claude Desktop. Here's all the ways you can set up your mcp-agent application: MCP-Agent Server You can expose mcp-agent applications as MCP servers themselves see example, allowing MCP clients to interface with sophisticated AI workflows using the standard tools API of MCP servers. This is effectively a server-of-servers. MCP Client or Host You can embed mcp-agent in an MCP client directly to manage the orchestration across multiple MCP servers. Standalone You can use mcp-agent applications in a standalone fashion i.e. they aren't part of an MCP client. The /examples/ are all standalone applications. Tell me a fun fact I debated naming this project silsila ÿ≥ŸÑÿ≥ŸÑ€Å, which means chain of events in Urdu. mcp-agent is more matter-of-fact, but there's still an easter egg in the project paying homage to silsila.