<img src="img/logo.svg" align="left" width="165" alt="timg logo" title="timg"> <!-- github markdown eats style, otherwise we could use em-units for width. --> Terminal Image and Video Viewer =============================== !License: GPL v2https://github.com/hzeller/timg/blob/main/LICENSE &nbsp; !Ubuntu Build../../actions/workflows/ubuntu.yml !macOS Build../../actions/workflows/macos.yml !macOS Brew Building HEAD../../actions/workflows/macos-brew.yml https://timg.sh/ A user-friendly terminal image viewer that uses graphic capabilities of terminals Sixel, Kitty or iterm2, or 24-Bit color capabilities and unicode character blocks if these are not available. On terminals that implement the sixel protocol, the Kitty Graphics Protocol, or the iTerm2 Graphics Protocol this displays images in full resolution. But even the fallback block display is usable. !./img/sunflower-term.png Displays regular images, plays animated gifs, scrolls static images and plays videos. Useful if you want to have a quick visual check without leaving the comfort of your shell and having to start a bulky image viewer. Sometimes this is the only way if your terminal is connected remotely via ssh. And of course if you don't need the resolution. While icons typically fit pixel-perfect, larger images are scaled down to match the resolution. The command line accepts any number of image/video filenames that it shows in sequence one per page or in a grid in multiple columns, depending on your choice of . The output is emitted in-line with minimally messing with your terminal, so you can simply go back in history using your terminals' scroll-bar Or redirecting the output to a file allows you to later simply that file to your terminal. Even seems to be happy with it. Pixelation On a regular terminal, block-characters are used to output images. Half blocks present pixels color-accurately, and quarter blocks provide a higher spatial resolution at the expense of slightly worse color accuracy. These modes should be compatible with most common terminals that support UTF8 and 24Bit color. If you are on a KittyKitty Graphics Protocol, iTerm2, or wezterm terminal, or a terminal that supports the sixel protocol, images can be shown in full resolution. -p kitty, -p iterm2, or -p sixel | -p quarter | -p half | ----------------------------------|------------|---------| !img/pixelation-kitty.png | !img/pixelation-quarter.png | !img/pixelation-half.png | Grid display Images can be shown in a grid, which is very useful if you quickly want to browse through a lot of images. You can choose to show the filename as title, so it is easy to find exactly the filename you're looking for The following grid uses and is pixelated . !Grid view of 4 pictures <details> <summary>This is how the same grid looks if no high-res mode is available with - ...</summary> !./img/grid-timg.png </details> Synopsis Examples Partially transparent icon on champagne-colored terminal emulator -b auto | -b lightgreen | -b lightgreen -B yellow | -b none | ---------|---------------|-------------------------|----------| !img/alpha-bauto.png | !img/alpha-blightgreen.png | !img/alpha-blightgreen-Byellow.png | !img/alpha-bnone.png --pattern-size=1 | --pattern-size=4 | ---------------------------------------|--------------------------------------| !img/alpha-blightgreen-Byellow.png | !img/alpha-blightgreen-Byellow-4.png | Include in file browsers There are many terminal based file-browsers. Adding to their configuration is usually straight forward. Other fun things Terminal considerations This section contains some details that you only might need to ever look at if the output is not as expected. Many terminals support direct hi-res image output The Kitty, iTerm2, and wezterm terminals as well as other modern terminals such as Konsole or the terminal in vscode allow to directly display high-resolution pictures. If is running in such a terminal, it will attempt to auto-detect that feature and use that mode. If your terminal does support the feature but can't be auto-detected, you can explicitly choose the pixelation option in question with command line flag or environment variable see . Please file an issue with if auto-detect does not work. VSCode Terminal The terminal in vscode to display images in high-resolution, you need to enable the Terminal > Integrated: Enable Images setting in vscode. Otherwise you have to explicitly choose to show the 'block' images. In tmux The terminal multiplexer prevents high-resolution images as it filters out the escape codes. However, with some ... workarounds, can show such pictures in >= version 3.3 iff in a kitty-terminal. So if you need hi-res pictures in tmux, use a kitty terminal; you also have to explicitly set the pixelation to see for details. Sixel Other terminals support an older high-resolution sixel-protocol, which you can choose with . Note, for this to work in xterm, you need to invoke it with . High resolution and low bandwidth If watching hi-res videos remotely is too slow due to high bandwidth requirements or simply because your terminal has to do more work, try setting the environment variable to allow timg leaving out frames to stay on track see , environment variable section. You can also attempt to set the level higher. Half block and quarter block rendering Terminals that do not support high-resolution image output can still show images by virtue of showing colored blocks. The half block pixelation uses the the unicode character ▄ or ▀ depending on the half-block-choice-of-rendering-block environment variable. If the top and bottom color is the same, a simple space with background color is used. The quarter block pixelation uses eight different blocks. With both of these pixelations, choosing the foreground color and background 24-bit color, can simulate 'pixels'. With the half-block pixelation, this can assign the correct color to the two 'pixels' available in one character cell, in the quarter pixelation, four 'pixels' have to share two colors, so the color accuracy is slighlty worse but it allows for higher spatial resolution. The command line flag allows to choose between , , also possible to just shorten to and . Default is see above how this looks like. Terminals that don't support Unicode or 24 bit color will probably not show a very pleasant output. For terminals that only do 8 bit color, use the command line option. Half block: Choice of rendering block By default, uses the 'lower half block' to show the pixels in mode. Depending on the font the terminal is using, using the upper block might look better, so it is possible to change the default with an environment variable. Play around with this value if the output looks poor on your terminal. I found that on my system there is no difference for konsole or but the cool-retro-term looks better with the lower block, this is why it is the default. In some terminals, such as alacritty and only with certain font sizes, there seems to be the opposite working better. To change, set this environment variable: this only will work fully with . In mode, there are additional blocks that can't be worked around What a problematic choice of block looks like The image generally looks a bit 'glitchy' if the terminal leaves little space between blocks, so that the wrong background color shows on a single line between pixels. This is likely not intended by the terminal emulator and possibly happening on rounding issues of font height or similar. Anyway, we can work around it fully in , partially in mode. In the following illustration you see how that looks like. If you see that, change the environment variable. Glitchy. Change TIMGUSEUPPERBLOCK| Looks good ------------------------------------|-------------------------------| !img/needs-block-change.png | !img/block-ok.png| Other artifacts Some terminals leave one pixel of horizontal space between characters that result in fine vertical lines in the image. That can't be worked around, send a bug or better pull request to your terminal emulator. Wrong font aspect ratio Usually, timg attempts to determine the font aspect ratio and apply some correction if it is off from the nominal 1:2. But if you notice that the image displayed is not quite the right aspect ratio because of the terminals font used, you can set an environment variable with a factor to make it look correctly. Increasing the visual width by 10% would be setting the value to 1.1 for instance. This is an environment variable, so that you can set it once to best fit your terminal emulator of choice and don't have to worry about later. Example Terminal font too narrow | Correct. Here with ---------------------------|-------------------------------| !img/aspect-wrong.png | !img/aspect-right.png| Sixel videos scroll or grid view looks like staircase If you have a Sixel terminal in which you observe artifacts such as videos 'scrolling' or the grid view not having images vertically aligned, you might need to set the environment variable. Unfortuantely, some Sixel terminals disagree if there is a newline after an image or not. Installation Install pre-built package <a href="https://repology.org/project/timg/versions"> <img src="https://repology.org/badge/vertical-allrepos/timg.svg" alt="Packaging status" align="right"> </a> Debian-based systems NixOS or Nix package manager macOS Use AppImage The timg release page also has a minimal binary in the AppImage package formatAppImage. To keep the size small, it does not include video decoding or some more fancy image formats. It is good for many contexts or if you want to try out , but for a full-featured binary, use one from your distribution or build from source. Build and Install from source Get dependencies on Debian/Ubuntu Get dependencies on NixOS or Nix package manager The dependencies are set-up in the shell.nix, so you're ready to go opening a nix shell Get dependencies on Fedora Get dependencies on macOS Get repo and compile timg In the script below you see that the build system allows for some compile-time choices: Use libsixel to output images in sixel graphics format. Default ON. allow for video decoding. Requires ffmpeg-related libraries. You typically want this ON default this allows for accessing connected video devices, e.g. you can watch your webcam input requires . This is the main image loading library so you typically want this ON default. If enabled, uses this for faster jpeg file loading. You typically want this ON default. High-quality and faster PDF renderer. Needs poppler and cairo. If not compiled-in, will fallback to GraphicsMagick, but that typically results in lower quality renderings. Typically want this ON default. High-quality SVG renderer. Needs librsvg and cairo. If not compiled-in, will fallback to GraphicsMagick, but that typically results in lower quality renderings. Typically want this ON default. Openslide is an image format used in scientific applications. Rarely used, so default off, switch ON if needed. Allow decoding of Quite Ok Image format QOI. Small and simple, default ON. Compile the simpler STB image library directly into the timg binary in cases where Graphicsmagick is not suitable for dependency pruning reasons; output can be slower and of less quality. It is default ON default but will always only attempted after other image loading fails. Turn off if you can use GraphicsMagick and want to reduce potential security vectors. You can choose these options by providing on the cmake command line, see below. 24-bit-term: https://gist.github.com/XVilka/8346728 cool-retro-term: https://github.com/Swordfish90/cool-retro-term konsole: https://konsole.kde.org/ alacritty: https://github.com/alacritty/alacritty Kitty: https://sw.kovidgoyal.net/kitty/ Kitty Graphics Protocol: https://sw.kovidgoyal.net/kitty/graphics-protocol.html iTerm2: https://iterm2.com/ iTerm2 Graphics Protocol: https://iterm2.com/documentation-images.html wezterm: https://wezfurlong.org/wezterm/ sixel: https://en.wikipedia.org/wiki/Sixel QOI: https://qoiformat.org/ vscode: https://code.visualstudio.com/ AppImage: https://appimage.org/