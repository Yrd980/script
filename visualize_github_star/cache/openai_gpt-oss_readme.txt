<img alt="gpt-oss-120" src="./docs/gpt-oss.svg"> <p align="center"> <a href="https://gpt-oss.com"><strong>Try gpt-oss</strong></a> · <a href="https://cookbook.openai.com/topic/gpt-oss"><strong>Guides</strong></a> · <a href="https://openai.com/index/gpt-oss-model-card"><strong>Model card</strong></a> · <a href="https://openai.com/index/introducing-gpt-oss/"><strong>OpenAI blog</strong></a> </p> <p align="center"> <strong>Download <a href="https://huggingface.co/openai/gpt-oss-120b">gpt-oss-120b</a> and <a href="https://huggingface.co/openai/gpt-oss-20b">gpt-oss-20b</a> on Hugging Face</strong> </p> <br> Welcome to the gpt-oss series, OpenAI's open-weight models designed for powerful reasoning, agentic tasks, and versatile developer use cases. We're releasing two flavors of these open models: - — for production, general purpose, high reasoning use cases that fit into a single 80GB GPU like NVIDIA H100 or AMD MI300X 117B parameters with 5.1B active parameters - — for lower latency, and local or specialized use cases 21B parameters with 3.6B active parameters Both models were trained using our harmony response formatharmony and should only be used with this format; otherwise, they will not work correctly. Highlights - Permissive Apache 2.0 license: Build freely without copyleft restrictions or patent risk—ideal for experimentation, customization, and commercial deployment. - Configurable reasoning effort: Easily adjust the reasoning effort low, medium, high based on your specific use case and latency needs. - Full chain-of-thought: Provides complete access to the model's reasoning process, facilitating easier debugging and greater trust in outputs. This information is not intended to be shown to end users. - Fine-tunable: Fully customize models to your specific use case through parameter fine-tuning. - Agentic capabilities: Use the models' native capabilities for function calling, web browsing, Python code execution, and Structured Outputs. - Native MXFP4 quantization: The models are trained with native MXFP4 precision for the MoE layer, allowing to run on a single 80GB GPU like NVIDIA H100 or AMD MI300X and to run within 16GB of memory. Inference examples Transformers You can use and with the Transformers library. If you use Transformers' chat template, it will automatically apply the harmony response formatharmony. If you use directly, you need to apply the harmony format manually using the chat template or use our harmony package. Learn more about how to use gpt-oss with Transformers. vLLM vLLM recommends using https://docs.astral.sh/uv/ for Python dependency management. You can use vLLM to spin up an OpenAI-compatible web server. The following command will automatically download the model and start the server. Learn more about how to use gpt-oss with vLLM. PyTorch / Triton / Metal These implementations are largely reference implementations for educational purposes and are not expected to be run in production. Learn more below. Ollama If you are trying to run on consumer hardware, you can use Ollama by running the following commands after installing Ollama. Learn more about how to use gpt-oss with Ollama. LM Studio If you are using LM Studio you can use the following commands to download. Check out our awesome list for a broader collection of gpt-oss resources and inference partners. About this repository This repository provides a collection of reference implementations: - Inference: - reference-pytorch-implementation — a non-optimized PyTorch implementation for educational purposes only. Requires at least 4× H100 GPUs due to lack of optimization. - reference-triton-implementation-single-gpu — a more optimized implementation using PyTorch & Triton incl. using CUDA graphs and basic caching - reference-metal-implementation — a Metal-specific implementation for running the models on Apple Silicon hardware - Tools: - browser — a reference implementation of the browser tool the models got trained on - python — a stateless reference implementation of the python tool the model got trained on - Client examples: - terminal-chat — a basic terminal chat application that uses the PyTorch or Triton implementations for inference along with the python and browser tools - responses-api — an example Responses API compatible server that implements the browser tool along with other Responses-compatible functionality Setup Requirements - Python 3.12 - On macOS: Install the Xcode CLI tools --> - On Linux: These reference implementations require CUDA - On Windows: These reference implementations have not been tested on Windows. Try using solutions like Ollama if you are trying to run the model locally. Installation If you want to try any of the code you can install it directly from PyPI If you want to modify the code or try the metal implementation set the project up locally: Download the model You can download the model weights from the Hugging Face Hub directly from Hugging Face CLI: Reference PyTorch implementation We include an inefficient reference PyTorch implementation in gptoss/torch/model.py. This code uses basic PyTorch operators to show the exact model architecture, with a small addition of supporting tensor parallelism in MoE so that the larger model can run with this code e.g., on 4xH100 or 2xH200. In this implementation, we upcast all weights to BF16 and run the model in BF16. To run the reference implementation, install the dependencies: And then run: Reference Triton implementation single GPU We also include an optimized reference implementation that uses an optimized triton MoE kernel that supports MXFP4. It also has some optimization on the attention code to reduce the memory cost. To run this implementation, the nightly version of triton and torch will be installed. This version can be run on a single 80GB GPU for . To install the reference Triton implementation run And then run: If you encounter , make sure to turn on the expandable allocator to avoid crashes when loading weights from the checkpoint. Reference Metal implementation Additionally we are providing a reference implementation for Metal to run on Apple Silicon. This implementation is not production-ready but is accurate to the PyTorch implementation. The implementation will get automatically compiled when running the installation on an Apple Silicon device: To perform inference you'll need to first convert the SafeTensor weights from Hugging Face into the right format using: Or download the pre-converted weights: To test it you can run: Harmony format & tools Along with the model, we are also releasing a new chat format library to interact with the model. Check this guide for more info about harmony. We also include two system tools for the model: browsing and python container. Check gptoss/tools for the tool implementation. Clients Terminal Chat The terminal chat application is a basic example of how to use the harmony format together with the PyTorch, Triton, and vLLM implementations. It also exposes both the python and browser tool as optional tools that can be used. > !NOTE > The torch and triton implementations require original checkpoint under and respectively. While vLLM uses the Hugging Face converted checkpoint under and root directory respectively. Responses API We also include an example Responses API server. This server does not implement every feature and event of the Responses API but should be compatible with most of the basic use cases and serve as inspiration for anyone building their own server. Some of our inference partners are also offering their own Responses API. You can start this server with the following inference backends: - — uses the triton implementation - — uses the metal implementation on Apple Silicon only - — uses the Ollama /api/generate API as an inference solution - — uses your installed vllm version to perform inference - — uses your installed transformers version to perform local inference Codex We support codex as a client for gpt-oss. To run the 20b version, set this to : This will work with any chat completions-API compatible server listening on port 11434, like ollama. Start the server and point codex to the oss model: Tools Browser > !WARNING > This implementation is purely for educational purposes and should not be used in production. You should implement your own equivalent of the gptoss/tools/simplebrowser/backend.py class with your own browsing environment. Both gpt-oss models were trained with the capability to browse using the tool that exposes the following three methods: - to search for key phrases - to open a particular page - to look for contents on a page Usage To enable the browser tool, you'll have to place the definition into the message of your harmony formatted prompt. You can either use the method if your tool implements the full interface or modify the definition using . For example: Details To control the context window size this tool uses a scrollable window of text that the model can interact with. So it might fetch the first 50 lines of a page and then scroll to the next 20 lines after that. The model has also been trained to then use citations from this tool in its answers. To improve performance the tool caches requests so that the model can revisit a different part of a page without having to reload the page. For that reason you should create a new browser instance for every request. Python The model was trained to use a python tool to perform calculations and other actions as part of its chain-of-thought. During the training the model used a stateful tool which makes running tools between CoT loops easier. This reference implementation, however, uses a stateless mode. As a result the PythonTool defines its own tool description to override the definition in harmony. > !WARNING > This implementation runs in a permissive Docker container which could be problematic in cases like prompt injections. It's serving as an example and you should consider implementing your own container restrictions in production. Usage To enable the python tool, you'll have to place the definition into the message of your harmony formatted prompt. You can either use the method if your tool implements the full interface or modify the definition using . For example: Apply Patch can be used to create, update or delete files locally. Other details Precision format We released the models with native quantization support. Specifically, we use MXFP4 for the linear projection weights in the MoE layer. We store the MoE tensor in two parts: - stores the actual fp4 values. We pack every two values in one value. - stores the block scale. The block scaling is done among the last dimension for all MXFP4 tensors. All other tensors will be in BF16. We also recommend using BF16 as the activation precision for the model. Recommended Sampling Parameters We recommend sampling with and . Contributing The reference implementations in this repository are meant as a starting point and inspiration. Outside of bug fixes we do not intend to accept new feature contributions. If you build implementations based on this code such as new tool implementations you are welcome to contribute them to the ./awesome-gpt-oss.md file. harmony: https://github.com/openai/harmony