MCP TypeScript SDK !NPM Version !MIT licensed Table of Contents - Overview - Installation - Quickstart - What is MCP? - Core Concepts - Server - Resources - Tools - Prompts - Completions - Sampling - Running Your Server - stdio - Streamable HTTP - Testing and Debugging - Examples - Echo Server - SQLite Explorer - Advanced Usage - Dynamic Servers - Low-Level Server - Writing MCP Clients - Proxy Authorization Requests Upstream - Backwards Compatibility - Documentation - Contributing - License Overview The Model Context Protocol allows applications to provide context for LLMs in a standardized way, separating the concerns of providing context from the actual LLM interaction. This TypeScript SDK implements the full MCP specification, making it easy to: - Build MCP clients that can connect to any MCP server - Create MCP servers that expose resources, prompts and tools - Use standard transports like stdio and Streamable HTTP - Handle all MCP protocol messages and lifecycle events Installation > ⚠️ MCP requires Node.js v18.x or higher to work fine. Quick Start Let's create a simple MCP server that exposes a calculator tool and some data: What is MCP? The Model Context Protocol MCP lets you build servers that expose data and functionality to LLM applications in a secure, standardized way. Think of it like a web API, but specifically designed for LLM interactions. MCP servers can: - Expose data through Resources think of these sort of like GET endpoints; they are used to load information into the LLM's context - Provide functionality through Tools sort of like POST endpoints; they are used to execute code or otherwise produce a side effect - Define interaction patterns through Prompts reusable templates for LLM interactions - And more! Core Concepts Server The McpServer is your core interface to the MCP protocol. It handles connection management, protocol compliance, and message routing: Resources Resources are how you expose data to LLMs. They're similar to GET endpoints in a REST API - they provide data but shouldn't perform significant computation or have side effects: Tools Tools let LLMs take actions through your server. Unlike resources, tools are expected to perform computation and have side effects: ResourceLinks Tools can return objects to reference resources without embedding their full content. This is essential for performance when dealing with large files or many resources - clients can then selectively read only the resources they need using the provided URIs. Prompts Prompts are reusable templates that help LLMs interact with your server effectively: Completions MCP supports argument completions to help users fill in prompt arguments and resource template parameters. See the examples above for resource completions and prompt completions. Client Usage Display Names and Metadata All resources, tools, and prompts support an optional field for better UI presentation. The is used as a display name, while remains the unique identifier. Note: The methods , , are the recommended approach for new code. The older methods , , remain available for backwards compatibility. Title Precedence for Tools For tools specifically, there are two ways to specify a title: - field in the tool configuration - field when using the older method with annotations The precedence order is: → → When building clients, use the provided utility to get the appropriate display name: Sampling MCP servers can request LLM completions from connected clients that support sampling. Running Your Server MCP servers in TypeScript need to be connected to a transport to communicate with clients. How you start the server depends on the choice of transport: stdio For command-line tools and direct integrations: Streamable HTTP For remote servers, set up a Streamable HTTP transport that handles both client requests and server-to-client notifications. With Session Management In some cases, servers need to be stateful. This is achieved by session management. > !TIP > When using this in a remote environment, make sure to allow the header parameter in CORS. Otherwise, it may result in a error. Read the following section for examples. CORS Configuration for Browser-Based Clients If you'd like your server to be accessible by browser-based MCP clients, you'll need to configure CORS headers. The header must be exposed for browser clients to access it: This configuration is necessary because: - The MCP streamable HTTP transport uses the header for session management - Browsers restrict access to response headers unless explicitly exposed via CORS - Without this configuration, browser-based clients won't be able to read the session ID from initialization responses Without Session Management Stateless For simpler use cases where session management isn't needed: This stateless approach is useful for: - Simple API wrappers - RESTful scenarios where each request is independent - Horizontally scaled deployments without shared session state DNS Rebinding Protection The Streamable HTTP transport includes DNS rebinding protection to prevent security vulnerabilities. By default, this protection is disabled for backwards compatibility. Important: If you are running this server locally, enable DNS rebinding protection: Testing and Debugging To test your server, you can use the MCP Inspector. See its README for more information. Examples Echo Server A simple server demonstrating resources, tools, and prompts: SQLite Explorer A more complex example showing database integration: Advanced Usage Dynamic Servers If you want to offer an initial set of tools/prompts/resources, but later add additional ones based on user action or external state change, you can add/update/remove them after the Server is connected. This will automatically emit the corresponding notifications: Improving Network Efficiency with Notification Debouncing When performing bulk updates that trigger notifications e.g., enabling or disabling multiple tools in a loop, the SDK can send a large number of messages in a short period. To improve performance and reduce network traffic, you can enable notification debouncing. This feature coalesces multiple, rapid calls for the same notification type into a single message. For example, if you disable five tools in a row, only one message will be sent instead of five. > !IMPORTANT > This feature is designed for "simple" notifications that do not carry unique data in their parameters. To prevent silent data loss, debouncing is automatically bypassed for any notification that contains a object or a . Such notifications will always be sent immediately. This is an opt-in feature configured during server initialization. Low-Level Server For more control, you can use the low-level Server class directly: Eliciting User Input MCP servers can request additional information from users through the elicitation feature. This is useful for interactive workflows where the server needs user input or confirmation: Client-side: Handle elicitation requests Note: Elicitation requires client support. Clients must declare the capability during initialization. Writing MCP Clients The SDK provides a high-level client interface: Proxy Authorization Requests Upstream You can proxy OAuth requests to an external authorization provider: This setup allows you to: - Forward OAuth requests to an external provider - Add custom token validation logic - Manage client registrations - Provide custom documentation URLs - Maintain control over the OAuth flow while delegating to an external provider Backwards Compatibility Clients and servers with StreamableHttp transport can maintain backwards compatibility with the deprecated HTTP+SSE transport from protocol version 2024-11-05 as follows Client-Side Compatibility For clients that need to work with both Streamable HTTP and older SSE servers: Server-Side Compatibility For servers that need to support both Streamable HTTP and older clients: Note: The SSE transport is now deprecated in favor of Streamable HTTP. New implementations should use Streamable HTTP, and existing SSE implementations should plan to migrate. Documentation - Model Context Protocol documentation - MCP Specification - Example Servers Contributing Issues and pull requests are welcome on GitHub at <https://github.com/modelcontextprotocol/typescript-sdk>. License This project is licensed under the MIT License—see the LICENSE file for details.