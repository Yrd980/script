Sloc Cloc and Code scc !SCC illustration A tool similar to cloc, sloccount and tokei. For counting the lines of code, blank lines, comment lines, and physical lines of source code in many programming languages. Goal is to be the fastest code counter possible, but also perform COCOMO calculation like sloccount, estimate code complexity similar to cyclomatic complexity calculators and produce unique lines of code or DRYness metrics. In short one tool to rule them all. Also it has a very short name which is easy to type . If you don't like sloc cloc and code feel free to use the name . !Gohttps://github.com/boyter/scc/actions/workflows/go.yml !Go Report Cardhttps://goreportcard.com/report/github.com/boyter/scc !Coverage Statushttps://coveralls.io/github/boyter/scc?branch=master !Scc Count Badgehttps://github.com/boyter/scc/ !Scc count downloads !Mentioned in Awesome Gohttps://github.com/avelino/awesome-go Licensed under MIT licence. Table of Contents - Install - Background - Pitch - Usage - Complexity Estimates - Unique Lines of Code ULOC - COCOMO - Output Formats - Performance - Development - Adding/Modifying Languages - Issues - Badges beta - Language Support scc for Teams & Enterprise While scc will always be a free and tool for individual developers, companies and businesses, we are exploring an enhanced version designed for teams and businesses. scc Enterprise will build on the core scc engine to provide historical analysis, team-level dashboards, and policy enforcement to help engineering leaders track code health, manage technical debt, and forecast project costs. We are currently gathering interest for a private beta. If you want to visualize your codebase's evolution, integrate quality gates into your CI/CD pipeline, and get a big-picture view across all your projects, sign up for the early access list here Install Go Install You can install by using the standard go toolchain. To install the latest stable version of scc: To install a development version: Note that needs go version >= 1.24. Snap A snap install exists thanks to Ricardo. NB Snap installed applications cannot run outside of <https://askubuntu.com/questions/930437/permission-denied-error-when-running-apps-installed-as-snap-packages-ubuntu-17> so you may encounter issues if you use snap and attempt to run outside this directory. Homebrew Or if you have Homebrew installed Fedora Fedora Linux users can use a COPR repository: MacPorts On macOS, you can also install via MacPorts Scoop Or if you are using Scoop on Windows Chocolatey Or if you are using Chocolatey on Windows WinGet Or if you are using WinGet on Windows FreeBSD On FreeBSD, scc is available as a package Or, if you prefer to build from source, you can use the ports tree Run in Docker Go to the directory you want to run scc from. Run the command below to run the latest release of scc on your current working directory: Manual Binaries for Windows, GNU/Linux and macOS for both i386 and x8664 machines are available from the releases page. GitLab <https://about.gitlab.com/blog/2023/02/15/code-counting-in-gitlab/> Other If you would like to assist with getting added into apt/chocolatey/etc... please submit a PR or at least raise an issue with instructions. Background Read all about how it came to be along with performance benchmarks, - <https://boyter.org/posts/sloc-cloc-code/> - <https://boyter.org/posts/why-count-lines-of-code/> - <https://boyter.org/posts/sloc-cloc-code-revisited/> - <https://boyter.org/posts/sloc-cloc-code-performance/> - <https://boyter.org/posts/sloc-cloc-code-performance-update/> Some reviews of - <https://nickmchardy.com/2018/10/counting-lines-of-code-in-koi-cms.html> - <https://www.feliciano.tech/blog/determine-source-code-size-and-complexity-with-scc/> - <https://metaredux.com/posts/2019/12/13/counting-lines.html> Setting up in GitLab - <https://about.gitlab.com/blog/2023/02/15/code-counting-in-gitlab/> A talk given at the first GopherCon AU about press S to see speaker notes - <https://boyter.org/static/gophercon-syd-presentation/> - <https://www.youtube.com/watch?v=jd-sjoy3GZo> For performance see the Performance section Other similar projects, - SLOCCount the original sloc counter - cloc, inspired by SLOCCount; implemented in Perl for portability - gocloc a sloc counter in Go inspired by tokei - loc rust implementation similar to tokei but often faster - loccount Go implementation written and maintained by ESR - polyglot ATS sloc counter - tokei fast, accurate and written in rust - sloc coffeescript code counter - stto new Go code counter with a focus on performance Interesting reading about other code counting projects tokei, loc, polyglot and loccount - <https://www.reddit.com/r/rust/comments/59bm3t/afastclocreplacementinrust/> - <https://www.reddit.com/r/rust/comments/82k9iy/loccountlinesofcodequickly/> - <http://blog.vmchale.com/article/polyglot-comparisons> - <http://esr.ibiblio.org/?p=8270> Further reading about processing files on the disk performance - <https://blog.burntsushi.net/ripgrep/> Using to process 40 TB of files from GitHub/Bitbucket/GitLab - <https://boyter.org/posts/an-informal-survey-of-10-million-github-bitbucket-gitlab-projects/> Pitch Why use ? - It is very fast and gets faster the more CPU you throw at it - Accurate - Works very well across multiple platforms without slowdown Windows, Linux, macOS - Large language support - Can ignore duplicate files - Has complexity estimations - You need to tell the difference between Coq and Verilog in the same directory - cloc yaml output support so potentially a drop in replacement for some users - Can identify or ignore minified files - Able to identify many ! files ADVANCED! <https://github.com/boyter/scc/issues/115> - Can ignore large files by lines or bytes - Can calculate the ULOC or unique lines of code by file, language or project - Supports multiple output formats for integration, CSV, SQL, JSON, HTML and more Why not use ? - You don't like Go for some reason - It cannot count D source with different nested multi-line comments correctly <https://github.com/boyter/scc/issues/27> Differences There are some important differences between and other tools that are out there. Here are a few important ones for you to consider. Blank lines inside comments are counted as comments. While the line is technically blank the decision was made that once in a comment everything there should be considered a comment until that comment is ended. As such the following, Would be counted as 4 lines of comments. This is noticeable when comparing scc's output to other tools on large repositories. is able to count verbatim strings correctly. For example in C the following, Because of the prefixed @ this string ends at the trailing " by ignoring the escape character \ and as such should be counted as 2 code lines and 1 comment. Some tools are unable to deal with this and instead count up to the "1.0.0" as a string which can cause the middle comment to be counted as code rather than a comment. will also tell you the number of bytes it has processed for most output formats allowing you to estimate the cost of running some static analysis tools. Usage Command line usage of is designed to be as simple as possible. Full details can be found in or . Note that the below reflects the state of master not a release, as such features listed below may be missing from your installation. Output should look something like the below for the redis project Note that you don't have to specify the directory you want to run against. Running will assume you want to run against the current directory. You can also run against multiple files or directories with the results aggregated in the output. Since writes to standard output, there are many ways to easily share the results. For example, using netcat and one of many pastebins gives a public URL: Ignore Files mostly supports .ignore files inside directories that it scans. This is similar to how ripgrep, ag and tokei work. .ignore files are 100% the same as .gitignore files with the same syntax, and as such will ignore files and directories listed in them. You can add .ignore files to ignore things like vendored dependency checked in files and such. The idea is allowing you to add a file or folder to git and have ignored in the count. It also supports its own ignore file if you want to ignore things while having ripgrep, ag, tokei and others support them. Interesting Use Cases Used inside Intel Nemu Hypervisor to track code changes between revisions <https://github.com/intel/nemu/blob/topic/virt-x86/tools/cloc-change.shL9> Appears to also be used inside both <http://codescoop.com/> <https://pinpoint.com/> <https://github.com/chaoss/grimoirelab-graal> It also is used to count code and guess language types in <https://searchcode.com/> which makes it one of the most frequently run code counters in the world. You can also hook scc into your gitlab pipeline <https://gitlab.com/guided-explorations/ci-cd-plugin-extensions/ci-cd-plugin-extension-scc> Also used by CodeQL <https://github.com/boyter/scc/pull/317> and Scaleway <https://twitter.com/Scaleway/status/1488087029476995074?s=20&t=N2-z6O-ISDdDzULg4o4uVQ> - <https://docs.linuxfoundation.org/lfx/insights/v3-beta-version-current/getting-started/landing-page/cocomo-cost-estimation-simplified> - <https://openems.io/> Features uses a small state machine in order to determine what state the code is when it reaches a newline . As such it is aware of and able to count - Single Line Comments - Multi Line Comments - Strings - Multi Line Strings - Blank lines Because of this it is able to accurately determine if a comment is in a string or is actually a comment. It also attempts to count the complexity of code. This is done by checking for branching operations in the code. For example, each of the following if encountered in Java would increment that files complexity by one. Complexity Estimates Let's take a minute to discuss the complexity estimate itself. The complexity estimate is really just a number that is only comparable to files in the same language. It should not be used to compare languages directly without weighting them. The reason for this is that its calculated by looking for branch and loop statements in the code and incrementing a counter for that file. Because some languages don't have loops and instead use recursion they can have a lower complexity count. Does this mean they are less complex? Probably not, but the tool cannot see this because it does not build an AST of the code as it only scans through it. Generally though the complexity there is to help estimate between projects written in the same language, or for finding the most complex file in a project which can be useful when you are estimating on how hard something is to maintain, or when looking for those files that should probably be refactored. As for how it works. It's my own definition, but tries to be an approximation of cyclomatic complexity <https://en.wikipedia.org/wiki/Cyclomaticcomplexity> although done only on a file level. The reason it's an approximation is that it's calculated almost for free from a CPU point of view since its a cheap lookup when counting, whereas a real cyclomatic complexity count would need to parse the code. It gives a reasonable guess in practice though even if it fails to identify recursive methods. The goal was never for it to be exact. In short when scc is looking through what it has identified as code if it notices what are usually branch conditions it will increment a counter. The conditions it looks for are compiled into the code and you can get an idea for them by looking at the JSON inside the repository. See <https://github.com/boyter/scc/blob/master/languages.jsonL3869> for an example of what it's looking at for a file that's Java. The increment happens for each of the matching conditions and produces the number you see. Unique Lines of Code ULOC ULOC stands for Unique Lines of Code and represents the unique lines across languages, files and the project itself. This idea was taken from <https://cmcenroe.me/2018/12/14/uloc.html> where the calculation is presented using standard Unix tools . This metric is there to assist with the estimation of complexity within the project. Quoting the source > In my opinion, the number this produces should be a better estimate of the complexity of a project. Compared to SLOC, not only are blank lines discounted, but so are close-brace lines and other repetitive code such as common includes. On the other hand, ULOC counts comments, which require just as much maintenance as the code around them does, while avoiding inflating the result with license headers which appear in every file, for example. You can obtain the ULOC by supplying the or argument to . It has a corresponding metric which is the percentage of ULOC to CLOC or . The higher the number the more DRY don't repeat yourself the project can be considered. In general a higher value here is a better as it indicates less duplicated code. The DRYness metric was taken from a comment by minimax <https://lobste.rs/s/has9r7/ulocuniquelinescode> To obtain the DRYness metric you can use the or argument to , which will implicitly set . Note that there is a performance penalty when calculating the ULOC metrics which can double the runtime. Running the uloc and DRYness calculations against C code a clone of redis produces an output as follows. Further reading about the ULOC calculation can be found at <https://boyter.org/posts/sloc-cloc-code-new-metic-uloc/> COCOMO The COCOMO statistics displayed at the bottom of any command line run can be configured as needed. To change the COCOMO parameters, you can either use one of the default COCOMO models. You can also supply your own parameters if you are familiar with COCOMO as follows, See below for details about how the model choices, and the parameters they use. Organic – A software project is said to be an organic type if the team size required is adequately small, the problem is well understood and has been solved in the past and also the team members have a nominal experience regarding the problem. Semi-detached – A software project is said to be a Semi-detached type if the vital characteristics such as team-size, experience, knowledge of the various programming environment lie in between that of organic and Embedded. The projects classified as Semi-Detached are comparatively less familiar and difficult to develop compared to the organic ones and require more experience and better guidance and creativity. Eg: Compilers or different Embedded Systems can be considered of Semi-Detached type. Embedded – A software project with requiring the highest level of complexity, creativity, and experience requirement fall under this category. Such software requires a larger team size than the other two models and also the developers need to be sufficiently experienced and creative to develop such complex models. Large File Detection You can have exclude large files from the output. The option to do so is which by default will exclude files over 1,000,000 bytes or 40,000 lines. You can control the size of either value using or . For example to exclude files over 1,000 lines and 50kb you could use the following, Minified/Generated File Detection You can have identify and optionally remove files identified as being minified or generated from the output. You can do so by enabling the flag like so which will identify any file with an average line byte size >= 255 by default as being minified. Minified files appear like so in the output. Minified files are indicated with the text after the language name. Generated files are indicated with the text after the language name. You can control the average line byte size using such as . Please note you need as modifying this value does not imply minified detection. You can exclude minified files from the count totally using the flag . Files which match the minified check will be excluded from the output. Remapping Some files may not have an extension. They will be checked to see if they are a ! file. If they are then the language will be remapped to the correct language. Otherwise, it will not process. However, you may have the situation where you want to remap such files based on a string inside it. To do so you can use The above will inspect any file with no extension looking for the string and if found remap the file to be counted using the C Header rules. You can have multiple remap rules if required, There is also the parameter which will remap all files. Note that in all cases if the remap rule does not apply normal ! rules will apply. Output Formats By default will output to the console. However, you can produce output in other formats if you require. The different options are . Note that you can write output to disk using the option. This allows you to specify a file to write your output to. For example will run against the current directory, and output the results in html to the file . You can also write to multiple output files, or multiple types to stdout if you want using the option. This is most useful when working in CI/CD systems where you want HTML reports as an artifact while also displaying the counts in stdout. The above will run against the current directory, outputting to standard output the default output, as well as writing to output.html and output.csv with the appropriate formats. Tabular This is the default output format when scc is run. Wide Wide produces some additional information which is the complexity/lines metric. This can be useful when trying to identify the most complex file inside a project based on the complexity estimate. JSON JSON produces JSON output. Mostly designed to allow to feed into other programs. Note that this format will give you the byte size of every file reads allowing you to get a breakdown of the number of bytes processed. CSV CSV as an option is good for importing into a spreadsheet for analysis. Note that this format will give you the byte size of every file reads allowing you to get a breakdown of the number of bytes processed. Also note that CSV respects and as such will return a summary by default. CSV-Stream csv-stream is an option useful for processing very large repositories where you are likely to run into memory issues. It's output format is 100% the same as CSV. Note that you should not use this with the option as it will always print to standard output, and because of how it works will negate the memory saving it normally gains. savings that this option provides. Note that there is no sort applied with this option. cloc-yaml Is a drop in replacement for cloc using its yaml output option. This is quite often used for passing into other build systems and can help with replacing cloc if required. HTML and HTML-TABLE The HTML output options produce a minimal html report using a table that is either standalone or as just a table which can be injected into your own HTML pages. The only difference between the two is that the option includes html head and body tags with minimal styling. The markup is designed to allow your own custom styles to be applied. An example report is here to view. Note that the HTML options follow the command line options, so you can use to produce a report with every file and not just the summary. Note that this format if it has the option will give you the byte size of every file reads allowing you to get a breakdown of the number of bytes processed. SQL and SQL-Insert The SQL output format "mostly" compatible with cloc's SQL output format <https://github.com/AlDanial/clocsql-> While all queries on the cloc documentation should work as expected, you will not be able to append output from and into the same database. This is because the table format is slightly different to account for scc including complexity counts and bytes. The difference between and is that will include table creation while the latter will only have the insert commands. Usage is 100% the same as any other command but sql output will always contain per file details. You can compute totals yourself using SQL, however COCOMO calculations will appear against the metadata table as the columns and . The below will run scc against the current directory, name the output as the project scc and then pipe the output to sqlite to put into the database code.db Assuming you then wanted to append another project You could then run SQL against the database, See the cloc documentation for more examples. OpenMetrics OpenMetrics is a metric reporting format specification extending the Prometheus exposition text format. The produced output is natively supported by Prometheus and GitLab CI Note that OpenMetrics respects and as such will return a summary by default. The output includes a metadata header containing definitions of the returned metrics: The header is followed by the metric data in either language summary form: or, if is present, in per file form: Performance Generally will the fastest code counter compared to any I am aware of and have compared against. The below comparisons are taken from the fastest alternative counters. See above to see all of the other code counters compared against. It is designed to scale to as many CPU's cores as you can provide. However, if you want greater performance and you have RAM to spare you can disable the garbage collector like the following on Linux which should speed things up considerably. For some repositories turning off the code complexity calculation via can reduce runtime as well. Benchmarks are run on fresh 48 Core CPU Optimised Digital Ocean Virtual Machine 2024/09/30 all done using hyperfine. See <https://github.com/boyter/scc/blob/master/benchmark.sh> to see how the benchmarks are run. Valkey <https://github.com/valkey-io/valkey> CPython <https://github.com/python/cpython> Linux Kernel <https://github.com/torvalds/linux> Sourcegraph <https://github.com/SINTEF/sourcegraph.git> Sourcegraph has gone dark since I last ran these benchmarks hence using a clone taken before this occured. The reason for this is to track what appears to be a performance regression in tokei. If you enable duplicate detection expect performance to fall by about 20% in . Performance is tracked for some releases and presented below. !scc perfromance on Linux kernel The decrease in performance from the 3.3.0 release was due to accurate .gitignore, .ignore and .gitmodule support. Current work is focussed on resolving this. <https://jsfiddle.net/mw21h9va/> CI/CD Support Some CI/CD systems which will remain nameless do not work very well with the box-lines used by . To support those systems better there is an option which will change the default output to ASCII only. The option is especially useful in CI/CD where you want to get multiple output formats useful for storage or reporting. Development If you want to hack away feel free! PR's are accepted. Some things to keep in mind. If you want to change a language definition you need to update and then run which will convert it into the file. For all other changes ensure you run all tests before submitting. You can do so using . However, for maximum coverage please run which will run , unit tests, race detector and then all of the integration tests. All of those must pass to ensure a stable release. API Support The core part of which is the counting engine is exposed publicly to be integrated into other Go applications. See <https://github.com/pinpt/ripsrc> for an example of how to do this. It also powers all of the code calculations displayed in <https://searchcode.com/> such as <https://searchcode.com/file/169350674/main.go/> making it one of the more used code counters in the world. However as a quick start consider the following, Note that you must pass in the number of bytes in the content in order to ensure it is counted! Adding/Modifying Languages To add or modify a language you will need to edit the file in the root of the project, and then run to build it into the application. You can then or as normal to produce the binary with your modifications. Issues Its possible that you may see the counts vary between runs. This usually means one of two things. Either something is changing or locking the files under scc, or that you are hitting ulimit restrictions. To change the ulimit see the following links. - <https://superuser.com/questions/261023/how-to-change-default-ulimit-values-in-mac-os-x-10-6306555> - <https://unix.stackexchange.com/questions/108174/how-to-persistently-control-maximum-system-resource-consumption-on-mac/221988221988> - <https://access.redhat.com/solutions/61334> - <https://serverfault.com/questions/356962/where-are-the-default-ulimit-values-set-linux-centos> - <https://www.tecmint.com/increase-set-open-file-limits-in-linux/> To help identify this issue run scc like so and look for the message in the output. If it is there you can rectify it by setting your ulimit to a higher value. Low Memory If you are running in a low memory environment < 512 MB of RAM you may need to set to a lower value such as to force the garbage collector to be on at all times. A sign that this is required will be crashing with panic errors. Tests scc is pretty well tested with many unit, integration and benchmarks to ensure that it is fast and complete. Package Packaging as of version v3.1.0 is done through <https://goreleaser.com/> Containers Note if you plan to run in Alpine containers you will need to build with CGOENABLED=0. See the below Dockerfile as an example on how to achieve this based on this issue <https://github.com/boyter/scc/issues/208> Badges beta You can use to provide badges on your github/bitbucket/gitlab/sr.ht open repositories. For example, !Scc Count Badgehttps://github.com/boyter/scc/ The format to do so is, <https://sloc.xyz/PROVIDER/USER/REPO> An example of the badge for is included below, and is used on this page. By default the badge will show the repo's lines count. You can also specify for it to show a different category, by using the query string. Valid values include and examples of the appearance are included below. !Scc Count Badgehttps://github.com/boyter/scc/ !Scc Count Badgehttps://github.com/boyter/scc/ !Scc Count Badgehttps://github.com/boyter/scc/ !Scc Count Badgehttps://github.com/boyter/scc/ !Scc Count Badgehttps://github.com/boyter/scc/ !Scc Count Badgehttps://github.com/boyter/scc/ For you can also set the value similar to itself. For example, <https://sloc.xyz/github/boyter/scc/?category=cocomo&avg-wage=1> <https://sloc.xyz/github/boyter/scc/?category=cocomo&avg-wage=100000> Note that the avg-wage value must be a positive integer otherwise it will revert back to the default value of 56286. You can also configure the look and feel of the bad using the following parameters, - ?lower=true will lower the title text, so "Total lines" would be "total lines" he below can control the colours of shadows, fonts and badges - ?font-color=fff - ?font-shadow-color=010101 - ?top-shadow-accent-color=bbb - ?title-bg-color=555 - ?badge-bg-color=4c1 An example of using some of these parameters to produce an admittedly ugly result !Scc Count Badgehttps://github.com/boyter/scc/ NB it may not work for VERY large repositories has been tested on Apache hadoop/spark without issue. You can find the source code for badges in the repository at <https://github.com/boyter/scc/blob/master/cmd/badges/main.go> A example for each supported provider - Github - <https://sloc.xyz/github/boyter/scc/> - sr.ht - <https://sloc.xyz/sr.ht/~nektro/magnolia-desktop/> - Bitbucket - <https://sloc.xyz/bitbucket/boyter/decodingcaptchas> - Gitlab - <https://sloc.xyz/gitlab/esr/loccount> Languages List of supported languages. The master version of supports 322 languages at last count. Note that this is always assumed that you built from master, and it might trail behind what is actually supported. To see what your version of supports run Click here to view all languages supported by master Release Checklist - Update version - Push code with release number - Tag off - Release via goreleaser - Update dockerfile