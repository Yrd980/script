<div align="center"> <img src="https://raw.githubusercontent.com/jax-ml/jax/main/images/jaxlogo250px.png" alt="logo"></img> </div> Transformable numerical computing at scale !Continuous integrationhttps://github.com/jax-ml/jax/actions/workflows/ci-build.yaml !PyPI versionhttps://pypi.org/project/jax/ Transformations | Scaling | Install guide | Change logs | Reference docs What is JAX? JAX is a Python library for accelerator-oriented array computation and program transformation, designed for high-performance numerical computing and large-scale machine learning. JAX can automatically differentiate native Python and NumPy functions. It can differentiate through loops, branches, recursion, and closures, and it can take derivatives of derivatives of derivatives. It supports reverse-mode differentiation a.k.a. backpropagation via automatic-differentiation-with-grad as well as forward-mode differentiation, and the two can be composed arbitrarily to any order. JAX uses XLA to compile and scale your NumPy programs on TPUs, GPUs, and other hardware accelerators. You can compile your own pure functions with compilation-with-jit. Compilation and automatic differentiation can be composed arbitrarily. Dig a little deeper, and you'll see that JAX is really an extensible system for composable function transformations at scale. This is a research project, not an official Google product. Expect sharp edges. Please help by trying it out, reporting bugs, and letting us know what you think! Contents Transformations Scaling Current gotchas Installation Neural net libraries Citing JAX Reference documentation Transformations At its core, JAX is an extensible system for transforming numerical functions. Here are three: , , and . Automatic differentiation with Use https://docs.jax.dev/en/latest/jax.htmljax.grad to efficiently compute reverse-mode gradients: You can differentiate to any order with : You're free to use differentiation with Python control flow: See the JAX Autodiff Cookbook and the reference docs on automatic differentiation for more. Compilation with Use XLA to compile your functions end-to-end with https://docs.jax.dev/en/latest/jax.htmljust-in-time-compilation-jit, used either as an decorator or as a higher-order function. Using constrains the kind of Python control flow the function can use; see the tutorial on Control Flow and Logical Operators with JIT for more. Auto-vectorization with https://docs.jax.dev/en/latest/jax.htmlvectorization-vmap maps a function along array axes. But instead of just looping over function applications, it pushes the loop down onto the function’s primitive operations, e.g. turning matrix-vector multiplies into matrix-matrix multiplies for better performance. Using can save you from having to carry around batch dimensions in your code: By composing with and , we can get efficient Jacobian matrices, or per-example gradients: Scaling To scale your computations across thousands of devices, you can use any composition of these: Compiler-based automatic parallelization where you program as if using a single global machine, and the compiler chooses how to shard data and partition computation with some user-provided constraints; Explicit sharding and automatic partitioning where you still have a global view but data shardings are explicit in JAX types, inspectable using ; Manual per-device programming where you have a per-device view of data and computation, and can communicate with explicit collectives. | Mode | View? | Explicit sharding? | Explicit Collectives? | |---|---|---|---| | Auto | Global | ❌ | ❌ | | Explicit | Global | ✅ | ❌ | | Manual | Per-device | ✅ | ✅ | See the tutorial and advanced guides for more. Gotchas and sharp bits See the Gotchas Notebook. Installation Supported platforms | | Linux x8664 | Linux aarch64 | Mac aarch64 | Windows x8664 | Windows WSL2 x8664 | |------------|--------------|---------------|--------------|----------------|---------------------| | CPU | yes | yes | yes | yes | yes | | NVIDIA GPU | yes | yes | n/a | no | experimental | | Google TPU | yes | n/a | n/a | n/a | n/a | | AMD GPU | yes | no | n/a | no | no | | Apple GPU | n/a | no | experimental | n/a | n/a | | Intel GPU | experimental | n/a | n/a | no | no | Instructions | Platform | Instructions | |-----------------|-----------------------------------------------------------------------------------------------------------------| | CPU | | | NVIDIA GPU | | | Google TPU | | | AMD GPU Linux | Follow AMD's instructions. | | Mac GPU | Follow Apple's instructions. | | Intel GPU | Follow Intel's instructions. | See the documentation for information on alternative installation strategies. These include compiling from source, installing with Docker, using other versions of CUDA, a community-supported conda build, and answers to some frequently-asked questions. Citing JAX To cite this repository: In the above bibtex entry, names are in alphabetical order, the version number is intended to be that from jax/version.py, and the year corresponds to the project's open-source release. A nascent version of JAX, supporting only automatic differentiation and compilation to XLA, was described in a paper that appeared at SysML 2018. We're currently working on covering JAX's ideas and capabilities in a more comprehensive and up-to-date paper. Reference documentation For details about the JAX API, see the reference documentation. For getting started as a JAX developer, see the developer documentation.