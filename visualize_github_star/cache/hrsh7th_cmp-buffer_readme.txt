cmp-buffer nvim-cmp source for buffer words. Setup Configuration The below source configuration are available. To set any of these options, do: keywordlength type: number Default: The number of characters that need to be typed to trigger auto-completion. keywordpattern type: string Default: A vim's regular expression for creating a word list from buffer content. You can set this to if you want to use the option for recognizing words. Lua's string literals are particularly useful here to avoid escaping all of the backslash characters used for writing regular expressions. NOTE: Be careful with where you set this option! You must do this: Instead of this: The second notation is allowed by nvim-cmp documented here, but it is meant for a different purpose and will not be detected by this plugin as the pattern for searching words. getbufnrs type: fun: number Default: A function that specifies the buffer numbers to complete. You can use the following pre-defined recipes. All buffers Visible buffers indexinginterval type: number Default: Optimization option. See the section Indexing. indexingbatchsize type: number Default: Optimization option. See the section Indexing. maxindexedlinelength type: number Default: 40 Kilobytes Optimization option. See the section Indexing. Locality bonus comparator distance-based sorting This source also provides a comparator function which uses information from the word indexer to sort completion results based on the distance of the word from the cursor line. It will also sort completion results coming from other sources, such as Language Servers, which might improve accuracy of their suggestions too. The usage is as follows: Indexing and how to optimize it When a buffer is opened, this source first has to scan all lines in the buffer, match all words and store all of their occurrences. This process is called indexing. When actually editing the text in the buffer, the index of words is kept up-to-date with changes to the buffer's contents, this is called watching. It is done by re-running the indexer on just the changed lines. Indexing happens completely asynchronously in background, unlike watching, which must be performed synchronously to ensure that the index of words is kept perfectly in-sync with the lines in the buffer. However, most of the time this will not be a problem since many typical text edit operations affect only one or two lines, unless you are pasting a 1000-line snippet. Note that you can freely edit the buffer while it is being indexed, the underlying algorithm is written in such a way that your changes will not break the index or cause errors. If a crash does happen - it is a bug, so please report it. The speed of indexing is configurable with two options: and . Essentially, when indexing, a timer is started, which pulls a batch of lines from the buffer, scans them for words, and repeats after milliseconds. Decreasing interval and/or increasing the batch size will make the indexer faster, but at the expense of higher CPU usage and more lag when editing the file while indexing is still in progress. Setting to a negative value will switch the indexer to the "synchronous" mode: this will process all lines in one go, take less time in total since no other code will be running on the Lua thread, but with the obvious downside that the editor UI will be blocked. The option controls plugin's behavior in files with very long lines. This is known to slow this source down significantly see issue 13, so by default it will take only the first few kilobytes of the line it is currently on. In other words, very long lines are not ignored, but only a part of them is indexed. Performance on large text files This source has been tested on code files of a few megabytes in size 5-10 and contains optimizations for them, however, the indexed words can still take up tens of megabytes of RAM if the file is large. So, if you wish to avoid accidentally running this source on big files, you can tweak , for example like this: Of course, this snippet can be combined with any other recipes for .