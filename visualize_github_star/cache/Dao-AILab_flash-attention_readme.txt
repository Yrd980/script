FlashAttention This repository provides the official implementation of FlashAttention and FlashAttention-2 from the following papers. FlashAttention: Fast and Memory-Efficient Exact Attention with IO-Awareness Tri Dao, Daniel Y. Fu, Stefano Ermon, Atri Rudra, Christopher Ré Paper: https://arxiv.org/abs/2205.14135 IEEE Spectrum article about our submission to the MLPerf 2.0 benchmark using FlashAttention. !FlashAttention FlashAttention-2: Faster Attention with Better Parallelism and Work Partitioning Tri Dao Paper: https://tridao.me/publications/flash2/flash2.pdf !FlashAttention-2 Usage We've been very happy to see FlashAttention being widely adopted in such a short time after its release. This page contains a partial list of places where FlashAttention is being used. FlashAttention and FlashAttention-2 are free to use and modify see LICENSE. Please cite and credit FlashAttention if you use it. FlashAttention-3 beta release FlashAttention-3 is optimized for Hopper GPUs e.g. H100. Blogpost: https://tridao.me/blog/2024/flash3/ Paper: https://tridao.me/publications/flash3/flash3.pdf !FlashAttention-3 speedup on H100 80GB SXM5 with FP16 This is a beta release for testing / benchmarking before we integrate that with the rest of the repo. Currently released: - FP16 / BF16 forward and backward, FP8 forward Requirements: H100 / H800 GPU, CUDA >= 12.3. We highly recommend CUDA 12.8 for best performance. To install: To run the test: Once the package is installed, you can import it as follows: Installation and features Requirements: - CUDA toolkit or ROCm toolkit - PyTorch 2.2 and above. - Python package - Python package - Linux. Might work for Windows starting v2.3.2 we've seen a few positive reports but Windows compilation still requires more testing. If you have ideas on how to set up prebuilt CUDA wheels for Windows, please reach out via Github issue. \ Make sure that is installed and that it works correctly e.g. then should return exit code 0. If not sometimes then returns a nonzero exit code, uninstall then reinstall . Without , compiling can take a very long time 2h since it does not use multiple CPU cores. With compiling takes 3-5 minutes on a 64-core machine using CUDA toolkit. To install: Alternatively you can compile from source: If your machine has less than 96GB of RAM and lots of CPU cores, might run too many parallel compilation jobs that could exhaust the amount of RAM. To limit the number of parallel compilation jobs, you can set the environment variable : Interface: NVIDIA CUDA Support Requirements: - CUDA 12.0 and above. We recommend the Pytorch container from Nvidia, which has all the required tools to install FlashAttention. FlashAttention-2 with CUDA currently supports: 1. Ampere, Ada, or Hopper GPUs e.g., A100, RTX 3090, RTX 4090, H100. Support for Turing GPUs T4, RTX 2080 is coming soon, please use FlashAttention 1.x for Turing GPUs for now. 2. Datatype fp16 and bf16 bf16 requires Ampere, Ada, or Hopper GPUs. 3. All head dimensions up to 256. ~~Head dim > 192 backward requires A100/A800 or H100/H800~~. Head dim 256 backward now works on consumer GPUs if there's no dropout as of flash-attn 2.5.5. AMD ROCm Support ROCm version has two backends. There is composablekernel ck which is the default backend and a Triton backend. They provide an implementation of FlashAttention-2. Requirements: - ROCm 6.0 and above. We recommend the Pytorch container from ROCm, which has all the required tools to install FlashAttention. Composable Kernel Backend FlashAttention-2 ROCm CK backend currently supports: 1. MI200 or MI300 GPUs. 2. Datatype fp16 and bf16 3. Both forward's and backward's head dimensions up to 256. Triton Backend The Triton implementation of the Flash Attention v2 is currently a work in progress. It supports AMD's CDNA MI200, MI300 and RDNA GPU's using fp16, bf16 and fp32 datatypes. These features are supported in Fwd and Bwd 1 Fwd and Bwd with causal masking 2 Variable sequence lengths 3 Arbitrary Q and KV sequence lengths 4 Arbitrary head sizes 5 Multi and grouped query attention 6 Dropout 7 Rotary embeddings 8 ALiBi We are working on the following things 1 Paged Attention 2 Sliding Window 3 FP8 4 Performance Improvements Getting Started To get started with the triton backend for AMD, follow the steps below. First install the recommended Triton version Then install Flash Attention with the flag set to . To test that things are working, you can run our tests. These tests take hours so you don't need to run the full thing. You can use autotune for better performance by using this flag Docker You can also use the Dockerfile below which does the above steps on top of the latest rocm/pytorch image. To build the docker file To run the docker image How to use FlashAttention The main functions implement scaled dot product attention softmaxQ @ K^T softmaxscale @ V: To see how these functions are used in a multi-head attention layer which includes QKV projection, output projection, see the MHA implementation. Changelog 2.0: Complete rewrite, 2x faster Upgrading from FlashAttention 1.x to FlashAttention-2 These functions have been renamed: - -> - -> - -> If the inputs have the same sequence lengths in the same batch, it is simpler and faster to use these functions: 2.1: Change behavior of causal flag If seqlenq != seqlenk and causal=True, the causal mask is aligned to the bottom right corner of the attention matrix, instead of the top-left corner. For example, if seqlenq = 2 and seqlenk = 5, the causal mask 1 = keep, 0 = masked out is: v2.0: 1 0 0 0 0 1 1 0 0 0 v2.1: 1 1 1 1 0 1 1 1 1 1 If seqlenq = 5 and seqlenk = 2, the causal mask is: v2.0: 1 0 1 1 1 1 1 1 1 1 v2.1: 0 0 0 0 0 0 1 0 1 1 If the row of the mask is all zero, the output will be zero. 2.2: Optimize for inference Optimize for inference iterative decoding when query has very small sequence length e.g., query sequence length = 1. The bottleneck here is to load KV cache as fast as possible, and we split the loading across different thread blocks, with a separate kernel to combine results. See the function with more features for inference perform rotary embedding, updating KV cache inplace. Thanks to the xformers team, and in particular Daniel Haziza, for this collaboration. 2.3: Local i.e., sliding window attention Implement sliding window attention i.e., local attention. Thanks to Mistral AI and in particular Timothée Lacroix for this contribution. Sliding window was used in the Mistral 7B model. 2.4: ALiBi attention with linear bias, deterministic backward pass. Implement ALiBi Press et al., 2021. Thanks to Sanghun Cho from Kakao Brain for this contribution. Implement deterministic backward pass. Thanks to engineers from Meituan for this contribution. 2.5: Paged KV cache. Support paged KV cache i.e., PagedAttention. Thanks to @beginlner for this contribution. 2.6: Softcapping. Support attention with softcapping, as used in Gemma-2 and Grok models. Thanks to @Narsil and @lucidrains for this contribution. 2.7: Compatibility with torch compile Thanks to @ani300 for this contribution. Performance We present expected speedup combined forward + backward pass and memory savings from using FlashAttention against PyTorch standard attention, depending on sequence length, on different GPUs speedup depends on memory bandwidth - we see more speedup on slower GPU memory. We currently have benchmarks for these GPUs: A100 H100 <!-- RTX 3090 --> <!-- T4 --> A100 We display FlashAttention speedup using these parameters: Head dimension 64 or 128, hidden dimension 2048 i.e. either 32 or 16 heads. Sequence length 512, 1k, 2k, 4k, 8k, 16k. Batch size set to 16k / seqlen. Speedup !FlashAttention speedup on A100 80GB SXM5 with FP16/BF16 Memory !FlashAttention memory We show memory savings in this graph note that memory footprint is the same no matter if you use dropout or masking. Memory savings are proportional to sequence length -- since standard attention has memory quadratic in sequence length, whereas FlashAttention has memory linear in sequence length. We see 10X memory savings at sequence length 2K, and 20X at 4K. As a result, FlashAttention can scale to much longer sequence lengths. H100 !FlashAttention speedup on H100 SXM5 with FP16/BF16 Full model code and training script We have released the full GPT model implementation. We also provide optimized implementations of other layers e.g., MLP, LayerNorm, cross-entropy loss, rotary embedding. Overall this speeds up training by 3-5x compared to the baseline implementation from Huggingface, reaching up to 225 TFLOPs/sec per A100, equivalent to 72% model FLOPs utilization we don't need any activation checkpointing. We also include a training script to train GPT2 on Openwebtext and GPT3 on The Pile. Triton implementation of FlashAttention Phil Tillet OpenAI has an experimental implementation of FlashAttention in Triton: https://github.com/openai/triton/blob/master/python/tutorials/06-fused-attention.py As Triton is a higher-level language than CUDA, it might be easier to understand and experiment with. The notations in the Triton implementation are also closer to what's used in our paper. We also have an experimental implementation in Triton that support attention bias e.g. ALiBi: https://github.com/Dao-AILab/flash-attention/blob/main/flashattn/flashattntriton.py Tests We test that FlashAttention produces the same output and gradient as a reference implementation, up to some numerical tolerance. In particular, we check that the maximum numerical error of FlashAttention is at most twice the numerical error of a baseline implementation in Pytorch for different head dimensions, input dtype, sequence length, causal / non-causal. To run the tests: When you encounter issues This new release of FlashAttention-2 has been tested on several GPT-style models, mostly on A100 GPUs. If you encounter bugs, please open a GitHub Issue! Tests To run the tests: Citation If you use this codebase, or otherwise found our work valuable, please cite: