<p align="center"> <img src="https://raw.githubusercontent.com/abetlen/llama-cpp-python/main/docs/icon.svg" style="height: 5rem; width: 5rem"> </p> Python Bindings for https://github.com/ggerganov/llama.cpp !Documentation Statushttps://llama-cpp-python.readthedocs.io/en/latest/?badge=latest !Testshttps://github.com/abetlen/llama-cpp-python/actions/workflows/test.yaml !PyPIhttps://pypi.org/project/llama-cpp-python/ !PyPI - Python Versionhttps://pypi.org/project/llama-cpp-python/ !PyPI - Licensehttps://pypi.org/project/llama-cpp-python/ !PyPI - Downloadshttps://pepy.tech/projects/llama-cpp-python !Github All Releases Simple Python bindings for @ggerganov's https://github.com/ggerganov/llama.cpp library. This package provides: - Low-level access to C API via interface. - High-level Python API for text completion - OpenAI-like API - LangChain compatibility - LlamaIndex compatibility - OpenAI compatible web server - Local Copilot replacement - Function Calling support - Vision API support - Multiple Models Documentation is available at https://llama-cpp-python.readthedocs.io/en/latest. Installation Requirements: - Python 3.8+ - C compiler - Linux: gcc or clang - Windows: Visual Studio or MinGW - MacOS: Xcode To install the package, run: This will also build from source and install it alongside this python package. If this fails, add to the see the full cmake build log. Pre-built Wheel New It is also possible to install a pre-built wheel with basic CPU support. Installation Configuration supports a number of hardware acceleration backends to speed up inference as well as backend specific options. See the llama.cpp README for a full list. All cmake build options can be set via the environment variable or via the cli flag during installation. <details open> <summary>Environment Variables</summary> </details> <details> <summary>CLI / requirements.txt</summary> They can also be set via command and saved to a file: </details> Supported Backends Below are some common backends, their build commands and any additional environment variables required. <details open> <summary>OpenBLAS CPU</summary> To install with OpenBLAS, set the and environment variables before installing: </details> <details> <summary>CUDA</summary> To install with CUDA support, set the environment variable before installing: Pre-built Wheel New It is also possible to install a pre-built wheel with CUDA support. As long as your system meets some requirements: - CUDA Version is 12.1, 12.2, 12.3, 12.4 or 12.5 - Python Version is 3.10, 3.11 or 3.12 Where is one of the following: - : CUDA 12.1 - : CUDA 12.2 - : CUDA 12.3 - : CUDA 12.4 - : CUDA 12.5 For example, to install the CUDA 12.1 wheel: </details> <details> <summary>Metal</summary> To install with Metal MPS, set the environment variable before installing: Pre-built Wheel New It is also possible to install a pre-built wheel with Metal support. As long as your system meets some requirements: - MacOS Version is 11.0 or later - Python Version is 3.10, 3.11 or 3.12 </details> <details> <summary>hipBLAS ROCm</summary> To install with hipBLAS / ROCm support for AMD cards, set the environment variable before installing: </details> <details> <summary>Vulkan</summary> To install with Vulkan support, set the environment variable before installing: </details> <details> <summary>SYCL</summary> To install with SYCL support, set the environment variable before installing: </details> <details> <summary>RPC</summary> To install with RPC support, set the environment variable before installing: </details> Windows Notes <details> <summary>Error: Can't find 'nmake' or 'CMAKECCOMPILER'</summary> If you run into issues where it complains it can't find or CMAKECCOMPILER, you can extract w64devkit as mentioned in llama.cpp repo and add those manually to CMAKEARGS before running install: See the above instructions and set to the BLAS backend you want to use. </details> MacOS Notes Detailed MacOS Metal GPU install documentation is available at docs/install/macos.md <details> <summary>M1 Mac Performance Issue</summary> Note: If you are using Apple Silicon M1 Mac, make sure you have installed a version of Python that supports arm64 architecture. For example: Otherwise, while installing it will build the llama.cpp x86 version which will be 10x slower on Apple Silicon M1 Mac. </details> <details> <summary>M Series Mac Error: </summary> Try installing with </details> Upgrading and Reinstalling To upgrade and rebuild add flags to the command to ensure the package is rebuilt from source. High-level API API Reference The high-level API provides a simple managed interface through the https://llama-cpp-python.readthedocs.io/en/latest/api-reference/llamacpp.Llama class. Below is a short example demonstrating how to use the high-level API to for basic text completion: By default generates completions in an OpenAI compatible format: Text completion is available through the https://llama-cpp-python.readthedocs.io/en/latest/api-reference/llamacpp.Llama.call and https://llama-cpp-python.readthedocs.io/en/latest/api-reference/llamacpp.Llama.createcompletion methods of the https://llama-cpp-python.readthedocs.io/en/latest/api-reference/llamacpp.Llama class. Pulling models from Hugging Face Hub You can download models in format directly from Hugging Face using the https://llama-cpp-python.readthedocs.io/en/latest/api-reference/llamacpp.Llama.frompretrained method. You'll need to install the package to use this feature . By default https://llama-cpp-python.readthedocs.io/en/latest/api-reference/llamacpp.Llama.frompretrained will download the model to the huggingface cache directory, you can then manage installed model files with the https://huggingface.co/docs/huggingfacehub/en/guides/cli tool. Chat Completion The high-level API also provides a simple interface for chat completion. Chat completion requires that the model knows how to format the messages into a single prompt. The class does this using pre-registered chat formats ie. , , , etc or by providing a custom chat handler object. The model will will format the messages into a single prompt using the following order of precedence: - Use the if provided - Use the if provided - Use the from the model's metadata should work for most new models, older models may not have this - else, fallback to the chat format Set to see the selected chat format. Chat completion is available through the https://llama-cpp-python.readthedocs.io/en/latest/api-reference/llamacpp.Llama.createchatcompletion method of the https://llama-cpp-python.readthedocs.io/en/latest/api-reference/llamacpp.Llama class. For OpenAI API v1 compatibility, you use the https://llama-cpp-python.readthedocs.io/en/latest/api-reference/llamacpp.Llama.createchatcompletionopenaiv1 method which will return pydantic models instead of dicts. JSON and JSON Schema Mode To constrain chat responses to only valid JSON or a specific JSON Schema use the argument in https://llama-cpp-python.readthedocs.io/en/latest/api-reference/llamacpp.Llama.createchatcompletion. JSON Mode The following example will constrain the response to valid JSON strings only. JSON Schema Mode To constrain the response further to a specific JSON Schema add the schema to the property of the argument. Function Calling The high-level API supports OpenAI compatible function and tool calling. This is possible through the pre-trained models chat format or through the generic chat format. <details> <summary>Functionary v2</summary> The various gguf-converted files for this set of models can be found here. Functionary is able to intelligently call functions and also analyze any provided function outputs to generate coherent responses. All v2 models of functionary supports parallel function calling. You can provide either or for the when initializing the Llama class. Due to discrepancies between llama.cpp and HuggingFace's tokenizers, it is required to provide HF Tokenizer for functionary. The class can be initialized and passed into the Llama class. This will override the default llama.cpp tokenizer used in Llama class. The tokenizer files are already included in the respective HF repositories hosting the gguf files. NOTE: There is no need to provide the default system messages used in Functionary as they are added automatically in the Functionary chat handler. Thus, the messages should contain just the chat messages and/or system messages that provide additional context for the model e.g.: datetime, etc.. </details> Multi-modal Models supports such as llava1.5 which allow the language model to read information from both text and images. Below are the supported multi-modal models and their respective chat handlers Python API and chat formats Server API. | Model | | | |:--- |:--- |:--- | | llava-v1.5-7b | | | | llava-v1.5-13b | | | | llava-v1.6-34b | | | | moondream2 | | | | nanollava | | | | llama-3-vision-alpha | | | | minicpm-v-2.6 | | | | qwen2.5-vl | | | Then you'll need to use a custom chat handler to load the clip model and process the chat messages and images. You can also pull the model from the Hugging Face Hub using the method. Note: Multi-modal models also support tool calling and JSON mode. <details> <summary>Loading a Local Image</summary> Images can be passed as base64 encoded data URIs. The following example demonstrates how to do this. </details> Speculative Decoding supports speculative decoding which allows the model to generate completions based on a draft model. The fastest way to use speculative decoding is through the class. Just pass this as a draft model to the class during initialization. Embeddings To generate text embeddings use https://llama-cpp-python.readthedocs.io/en/latest/api-reference/llamacpp.Llama.createembedding or https://llama-cpp-python.readthedocs.io/en/latest/api-reference/llamacpp.Llama.embed. Note that you must pass to the constructor upon model creation for these to work properly. There are two primary notions of embeddings in a Transformer-style model: token level and sequence level. Sequence level embeddings are produced by "pooling" token level embeddings together, usually by averaging them or using the first token. Models that are explicitly geared towards embeddings will usually return sequence level embeddings by default, one for each input string. Non-embedding models such as those designed for text generation will typically return only token level embeddings, one for each token in each sequence. Thus the dimensionality of the return type will be one higher for token level embeddings. It is possible to control pooling behavior in some cases using the flag on model creation. You can ensure token level embeddings from any model using . The reverse, getting a generation oriented model to yield sequence level embeddings is currently not possible, but you can always do the pooling manually. Adjusting the Context Window The context window of the Llama models determines the maximum number of tokens that can be processed at once. By default, this is set to 512 tokens, but can be adjusted based on your requirements. For instance, if you want to work with larger contexts, you can expand the context window by setting the nctx parameter when initializing the Llama object: OpenAI Compatible Web Server offers a web server which aims to act as a drop-in replacement for the OpenAI API. This allows you to use llama.cpp compatible models with any OpenAI compatible client language libraries, services, etc. To install the server package and get started: Similar to Hardware Acceleration section above, you can also install with GPU cuBLAS support like this: Navigate to http://localhost:8000/docs to see the OpenAPI documentation. To bind to to enable remote connections, use . Similarly, to change the port default is 8000, use . You probably also want to set the prompt format. For chatml, use That will format the prompt according to how model expects it. You can find the prompt format in the model card. For possible options, see llamacpp/llamachatformat.py and look for lines starting with "@registerchatformat". If you have installed, you can also use the flag to load a model from the Hugging Face Hub. Web Server Features - Local Copilot replacement - Function Calling support - Vision API support - Multiple Models Docker image A Docker image is available on GHCR. To run the server: Docker on termux requires root is currently the only known way to run this on phones, see termux support issue Low-level API API Reference The low-level API is a direct https://docs.python.org/3/library/ctypes.html binding to the C API provided by . The entire low-level API can be found in llamacpp/llamacpp.py and directly mirrors the C API in llama.h. Below is a short example demonstrating how to use the low-level API to tokenize a prompt: Check out the examples folder for more examples of using the low-level API. Documentation Documentation is available via https://llama-cpp-python.readthedocs.io/. If you find any issues with the documentation, please open an issue or submit a PR. Development This package is under active development and I welcome any contributions. To get started, clone the repository and install the package in editable / development mode: Now try running the tests There's a available with useful targets. A typical workflow would look like this: You can also test out specific commits of by checking out the desired commit in the submodule and then running and again. Any changes in the API will require changes to the file to match the new API additional changes may be required elsewhere. FAQ Are there pre-built binaries / binary wheels available? The recommended installation method is to install from source as described above. The reason for this is that is built with compiler optimizations that are specific to your system. Using pre-built binaries would require disabling these optimizations or supporting a large number of pre-built binaries for each platform. That being said there are some pre-built binaries available through the Releases as well as some community provided wheels. In the future, I would like to provide pre-built binaries and wheels for common platforms and I'm happy to accept any useful contributions in this area. This is currently being tracked in 741 How does this compare to other Python bindings of ? I originally wrote this package for my own use with two goals in mind: - Provide a simple process to install and access the full C API in from Python - Provide a high-level Python API that can be used as a drop-in replacement for the OpenAI API so existing apps can be easily ported to use Any contributions and changes to this package will be made with these goals in mind. License This project is licensed under the terms of the MIT license.