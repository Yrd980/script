NOTICE: This repository is currently unmaintained. For the time being as of August, 2023, it is recommended to use one of the following plugin managers instead: - lazy.nvim: Most stable and maintained plugin manager for Nvim. - pckr.nvim: Spiritual successor of packer.nvim. Functional but not as stable as lazy.nvim. packer.nvim !Gitterhttps://gitter.im/packer-nvim/community?utmsource=badge&utmmedium=badge&utmcampaign=pr-badge https://github.com/jwiegley/use-package inspired plugin/package management for Neovim. Have questions? Start a discussion. Have a problem or idea? Make an issue or a PR. Packer is built on native packages. You may wish to read before continuing Table of Contents 1. Features 2. Requirements 3. Quickstart 4. Bootstrapping 5. Usage 1. The startup function 2. Custom Initialization 3. Specifying Plugins 4. Performing plugin management operations 5. Extending packer 6. Compiling Lazy-Loaders 7. User autocommands 8. Using a floating window 6. Profiling 7. Debugging 8. Compatibility and known issues 9. Contributors Features - Declarative plugin specification - Support for dependencies - Support for Luarocks dependencies - Expressive configuration and lazy-loading options - Automatically compiles efficient lazy-loading code to improve startup time - Uses native packages - Extensible - Written in Lua, configured in Lua - Post-install/update hooks - Uses jobs for async installation - Support for tags, branches, revisions, submodules - Support for local plugins Requirements - You need to be running Neovim v0.5.0+ - If you are on Windows 10, you need developer mode enabled in order to use local plugins creating symbolic links requires admin privileges on Windows - credit to @TimUntersberger for this note Quickstart To get started, first clone this repository to somewhere on your , e.g.: > Unix, Linux Installation If you use Arch Linux, there is also an AUR package. > Windows Powershell Installation Then you can write your plugin specification in Lua, e.g. in : Note that if you get linter complaints about being an undefined global, these errors are spurious - injects into the scope of the function passed to . If these errors bother you, the easiest fix is to simply specify as an argument to the function you pass to , e.g. provides the following commands after you've run and configured with : You can configure Neovim to automatically run whenever is updated with an autocommand: This autocommand can be placed in your , or any other startup file as per your setup. Placing this in could look like this: Bootstrapping If you want to automatically install and set up on any machine you clone your configuration to, add the following snippet which is due to @Iron-E and @khuedoan somewhere in your config before your first usage of : You can also use the following command with bootstrapped to have setup your configuration or simply run updates and close once all operations are completed: Usage The above snippets give some examples of features and use. Examples include: - My dotfiles: - Specification file - Loading file - Generated lazy-loader file - An example using the method: tjdevries - Using this method, you do not require a "loading" file. You can simply from your The following is a more in-depth explanation of 's features and use. The function provides , which is used in the above examples. is a convenience function for simple setup and can be invoked as follows: - can be a function: - can be a table with a function as its first element and config overrides as another element: - can be a table with a table of plugin specifications as its first element, config overrides as another element, and optional rock specifications as another element: Custom Initialization You are not required to use if you prefer a more manual setup with finer control over configuration and loading. To take this approach, load like any other Lua module. You must call before performing any operations; it is recommended to call if you may be re-running your specification code e.g. by sourcing your plugin specification file with . You may pass a table of configuration values to to customize its operation. The default configuration values and structure of the configuration table are: Specifying plugins is based around declarative specification of plugins. You can declare a plugin using the function , which I highly recommend locally binding to for conciseness. takes either a string or a table. If a string is provided, it is treated as a plugin location for a non-optional plugin with no additional configuration. Plugin locations may be specified as 1. Absolute paths to a local plugin 2. Full URLs treated as plugins managed with 3. paths treated as Github plugins A table given to can take two forms: 1. A list of plugin specifications strings or tables 2. A table specifying a single plugin. It must have a plugin location string as its first element, and may additionally have a number of optional keyword elements, shown below: For the option, the command may be a full command, or an autocommand pattern. If the command contains any non-alphanumeric characters, it is assumed to be a pattern, and instead of creating a stub command, it creates a CmdUndefined autocmd to load the plugin when a command that matches the pattern is invoked. Checking plugin statuses You can check whether or not a particular plugin is installed with as well as if that plugin is loaded. To do this you can check for the plugin's name in the global table. Plugins in this table are saved using only the last section of their names e.g. if installed will be under the key . NOTE: this table is only available after is loaded so cannot be used till after plugins have been loaded. Luarocks support You may specify that a plugin requires one or more Luarocks packages using the key. This key takes either a string specifying the name of a package e.g. , or a list specifying one or more packages. Entries in the list may either be strings, a list of strings or a table --- the latter case is used to specify arguments such as the particular version of a package. all supported luarocks keys are allowed except: and . Environment variables for the luarocks command can also be specified using the key which takes a table as the value as shown below. Currently, only supports equality constraints on package versions. also provides the function , which creates the command. must be one of "install" or "remove"; is one or more package names currently, version restrictions are not supported with this command. Running will install or remove the given packages. You can use this command even if you don't use to manage your plugins. However, please note that 1 packages installed through will be removed by calls to unless they are also part of a plugin specification, and 2 you will need to manually invoke or otherwise modify your to ensure that Neovim can find the installed packages. Finally, provides the function , which takes a string or table specifying one or more Luarocks packages as in the key. You can use this to ensure that downloads and manages some rocks which you want to use, but which are not associated with any particular plugin. Custom installers You may specify a custom installer & updater for a plugin using the and keys. Note that either both or none of these keys are required. These keys should be functions which take as an argument a object from and return an async function per which respectively installs/updates the given plugin. Providing the / keys overrides plugin type detection, but you still need to provide a location string for the name of the plugin. Update/install hooks You may specify operations to be run after successful installs/updates of a plugin with the key. This key may either be a Lua function, which will be called with the table for this plugin containing the information passed to as well as output from the installation/update commands, the installation path of the plugin, etc., a string, or a table of functions and strings. If an element of is a string, then either: 1. If the first character of is ":", it is treated as a Neovim command and executed. 2. Otherwise, is treated as a shell command and run in the installation directory of the plugin via . Dependencies Plugins may specify dependencies via the key. This key can be a string or a list table. If is a string, it is treated as specifying a single plugin. If a plugin with the name given in is already known in the managed set, nothing happens. Otherwise, the string is treated as a plugin location string and the corresponding plugin is added to the managed set. If is a list, it is treated as a list of plugin specifications following the format given above. If is true, the plugins specified in will be installed. Plugins specified in are removed when no active plugins require them. Sequencing You may specify a loading order for plugins using the key. This key can be a string or a list table. If is a string, it must be the name of another plugin managed by e.g. the final segment of a plugin's path - for a Github plugin , the name would be just . If is a table, it must be a list of plugin names. If a plugin has an alias i.e. uses the key, this alias is its name. The set of plugins specified in a plugin's key must all be loaded before the plugin using will be loaded. For example, in the specification the plugin will only be loaded after the plugin , which itself is only loaded for files with filetype. Keybindings Plugins may be lazy-loaded on the use of keybindings/maps. Individual keybindings are specified either as a string in which case they are treated as normal mode maps or a table in the format . Performing plugin management operations exposes the following functions for common plugin management operations. In all of the below, is an optional table of plugin names; if not provided, the default is "all managed plugins": - : Install the specified plugins if they are not already installed - : Update the specified plugins, installing any that are missing - : First argument can be a table specifying options, such as to preview potential changes before updating same as . - : Remove any disabled or no longer managed plugins - : Perform a followed by an . - : Can take same optional options as . - : Compile lazy-loader code and save to . - : Creates a snapshot file that will live under . If is an absolute path, then that will be the location where the snapshot will be taken. Optionally, a list of plugins name can be provided to selectively choose the plugins to snapshot. - : Rollback plugins status a snapshot file that will live under . If is an absolute path, then that will be the location where the snapshot will be taken. Optionally, a list of plugins name can be provided to selectively choose which plugins to revert. - : Deletes a snapshot file under . If is an absolute path, then that will be the location where the snapshot will be deleted. Extending You can add custom key handlers to by calling where is the key you wish to handle and is a function with the signature where is the global table of managed plugins, is the table for a specific plugin, and is the value associated with key in . Compiling Lazy-Loaders To optimize startup time, compiles code to perform the lazy-loading operations you specify. This means that you do not need to load unless you want to perform some plugin management operations. To generate the compiled code, call , where is some file path on your , with a extension. This will generate a blend of Lua and Vimscript to load and configure all your lazy-loaded plugins e.g. generating commands, autocommands, etc. and save it to . Then, when you start vim, the file at is loaded because must be on your , and lazy-loading works. If is not provided to , the output file will default to the value of . The option , which defaults to , will run during , if set to . Note that otherwise, you must run yourself to generate the lazy-loader file! NOTE: If you use a function value for or keys in any plugin specifications, it must not have any upvalues i.e. captures. We currently use Lua's to compile config/setup functions to bytecode, which has this limitation. Additionally, if functions are given for these keys, the functions will be passed the plugin name and information table as arguments. User autocommands runs most of its operations asyncronously. If you would like to implement automations that require knowing when the operations are complete, you can use the following autocmds see for more info on how to use: - : Fires after install, update, clean, and sync asynchronous operations finish. - : Fires after compiling see the section on compilation Using a floating window You can configure Packer to use a floating window for command outputs by passing a utility function to 's config: By default, this floating window will show doubled borders. If you want to customize the window appearance, you can pass a configuration to , which is the same configuration that would be passed to : Profiling Packer has built in functionality that can allow you to profile the time taken loading your plugins. In order to use this functionality you must either enable profiling in your config, or pass in an argument when running packer compile. Setup via config Using the packer compile command Profiling usage This will rebuild your with profiling code included. In order to visualise the output of the profile restart your neovim and run . This will open a window with the output of your profiling. Debugging logs to . Looking at this file is usually a good start if something isn't working as expected. Compatibility and known issues - 2021-07-31: If you're on macOS, note that building Neovim with the version of from will cause any command to crash. More about this issue at neovim/neovim15054. - 2021-07-28: will now highlight commits/plugin names with potentially breaking changes determined by looking for or , case insensitive, in the update commit bodies and headers as in the status window. - 2021-06-06: Your Neovim must include https://github.com/neovim/neovim/pull/14659; uses the key. - 2021-04-19: now provides built-in profiling for your config via the file. Take a look at the docs for more information! - 2021-02-18: Having trouble with Luarocks on macOS? See this issue. - 2021-01-19: Basic Luarocks support has landed! Use the key with a string or table to specify packages to install. - 2020-12-10: The configuration flag now affects non- use as well. This means that, by default, will create commands for basic operations for you. - 2020-11-13: There is now a default implementation for a floating window in . - 2020-09-04: Due to changes to the Neovim api see: https://github.com/neovim/neovim/commit/3853276d9cacc99a2698117e904475dbf7033383, users will need to update to a version of Neovim after the aforementioned PR was merged. There are currently shims around the changed functions which should maintain support for earlier versions of Neovim, but these are intended to be temporary and will be removed by 2020-10-04. Therefore Packer will not work with Neovim v0.4.4, which was released before the change. Contributors Many thanks to those who have contributed to the project! PRs and issues are always welcome. This list is infrequently updated; please feel free to bug me if you're not listed here and you would like to be. - @akinsho - @nanotee - @weilbith - @Iron-E - @tjdevries - @numToStr - @fsouza - @gbrlsnchs - @lewis6991 - @TimUntersberger - @bfredl - @sunjon - @gwerbin - @shadmansaleh - @ur4ltz - @EdenEast - @khuedoan - @kevinhwang91 - @runiq - @n3wborn - @deathlyfrantic - @doctoromer - @elianiva - @dundargoc - @jdelkins - @dsully