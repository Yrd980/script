Logrus <img src="http://i.imgur.com/hTeVwmJ.png" width="40" height="40" alt=":walrus:" class="emoji" title=":walrus:"/> !Build Statushttps://github.com/sirupsen/logrus/actions?query=workflow%3ACI !Go Referencehttps://pkg.go.dev/github.com/sirupsen/logrus Logrus is a structured logger for Go golang, completely API compatible with the standard library logger. Logrus is in maintenance-mode. We will not be introducing new features. It's simply too hard to do in a way that won't break many people's projects, which is the last thing you want from your Logging library again.... This does not mean Logrus is dead. Logrus will continue to be maintained for security, backwards compatible bug fixes, and performance where we are limited by the interface. I believe Logrus' biggest contribution is to have played a part in today's widespread use of structured logging in Golang. There doesn't seem to be a reason to do a major, breaking iteration into Logrus V2, since the fantastic Go community has built those independently. Many fantastic alternatives have sprung up. Logrus would look like those, had it been re-designed with what we know about structured logging in Go today. Check out, for example, Zerologzerolog, Zapzap, and Apexapex. zerolog: https://github.com/rs/zerolog zap: https://github.com/uber-go/zap apex: https://github.com/apex/log Seeing weird case-sensitive problems? It's in the past been possible to import Logrus as both upper- and lower-case. Due to the Go package environment, this caused issues in the community and we needed a standard. Some environments experienced problems with the upper-case variant, so the lower-case was decided. Everything using will need to use the lower-case: . Any package that isn't, should be changed. To fix Glide, see these comments. For an in-depth explanation of the casing issue, see this comment. Nicely color-coded in development when a TTY is attached, otherwise just plain text: !Colored With , for easy parsing by logstash or Splunk: With the default when a TTY is not attached, the output is compatible with the logfmt format: To ensure this behaviour even if a TTY is attached, set your formatter as follows: Logging Method Name If you wish to add the calling method as a field, instruct the logger via: This adds the caller as 'method' like so: Note that this does add measurable overhead - the cost will depend on the version of Go, but is between 20 and 40% in recent tests with 1.6 and 1.7. You can validate this in your environment via benchmarks: Case-sensitivity The organization's name was changed to lower-case--and this will not be changed back. If you are getting import conflicts due to case sensitivity, please use the lower-case import: . Example The simplest way to use Logrus is simply the package-level exported logger: Note that it's completely api-compatible with the stdlib logger, so you can replace your imports everywhere with and you'll now have the flexibility of Logrus. You can customize it all you want: For more advanced usage such as logging to multiple locations from the same application, you can also create an instance of the Logger: Fields Logrus encourages careful, structured logging through logging fields instead of long, unparseable error messages. For example, instead of: , you should log the much more discoverable: We've found this API forces you to think about logging in a way that produces much more useful logging messages. We've been in countless situations where just a single added field to a log statement that was already there would've saved us hours. The call is optional. In general, with Logrus using any of the -family functions should be seen as a hint you should add a field, however, you can still use the -family functions with Logrus. Default Fields Often it's helpful to have fields always attached to log statements in an application or parts of one. For example, you may want to always log the and in the context of a request. Instead of writing on every line, you can create a to pass around instead: Hooks You can add hooks for logging levels. For example to send errors to an exception tracking service on , and , info to StatsD or log to multiple places simultaneously, e.g. syslog. Logrus comes with built-in hooks. Add those, or your custom hook, in : Note: Syslog hooks also support connecting to local syslog Ex. "/dev/log" or "/var/run/syslog" or "/var/run/log". For the detail, please check the syslog hook README. A list of currently known service hooks can be found in this wiki page Level logging Logrus has seven logging levels: Trace, Debug, Info, Warning, Error, Fatal and Panic. You can set the logging level on a , then it will only log entries with that severity or anything above it: It may be useful to set in a debug or verbose environment if your application has that. Note: If you want different log levels for global and syslog logging, please check the syslog hook README. Entries Besides the fields added with or some fields are automatically added to all logging events: 1. . The timestamp when the entry was created. 2. . The logging message passed to after the call. E.g. 3. . The logging level. E.g. . Environments Logrus has no notion of environment. If you wish for hooks and formatters to only be used in specific environments, you should handle that yourself. For example, if your application has a global variable , which is a string representation of the environment you could do: This configuration is how was intended to be used, but JSON in production is mostly only useful if you do log aggregation with tools like Splunk or Logstash. Formatters The built-in logging formatters are: . Logs the event in colors if stdout is a tty, otherwise without colors. Note: to force colored output when there is no TTY, set the field to . To force no colored output even if there is a TTY set the field to . For Windows, see github.com/mattn/go-colorable. When colors are enabled, levels are truncated to 4 characters by default. To disable truncation set the field to . When outputting to a TTY, it's often helpful to visually scan down a column where all the levels are the same width. Setting the field to enables this behavior, by adding padding to the level text. All options are listed in the generated docs. . Logs fields as JSON. All options are listed in the generated docs. Third-party logging formatters: https://github.com/joonix/log. Formats entries that can be parsed by Kubernetes and Google Container Engine. https://github.com/fabienm/go-logrus-formatters. Formats entries so they comply to Graylog's GELF 1.1 specification. https://github.com/bshuster-repo/logrus-logstash-hook. Logs fields as Logstash Events. https://github.com/x-cray/logrus-prefixed-formatter. Displays log entry source along with alternative layout. https://github.com/aybabtme/logzalgo. Invoking the Power of Zalgo. https://github.com/antonfisher/nested-logrus-formatter. Converts logrus fields to a nested structure. https://github.com/zput/zxcTool. get fileName, log's line number and the latest function's name when print log; Save log to files. https://github.com/nolleh/captionjsonformatter. logrus's message json formatter with human-readable caption added. You can define your formatter by implementing the interface, requiring a method. takes an . is a type with all your fields as well as the default ones see Entries section above: Logger as an Logrus can be transformed into an . That writer is the end of an and it is your responsibility to close it. Each line written to that writer will be printed the usual way, using formatters and hooks. The level for those entries is . This means that we can override the standard library logger easily: Rotation Log rotation is not provided with Logrus. Log rotation should be done by an external program like that can compress and delete old log entries. It should not be a feature of the application-level logger. Tools | Tool | Description | | ---- | ----------- | |Logrus Mate|Logrus mate is a tool for Logrus to manage loggers, you can initial logger's level, hook and formatter by config file, the logger will be generated with different configs in different environments.| |Logrus Viper Helper|An Helper around Logrus to wrap with spf13/Viper to load configuration with fangs! And to simplify Logrus configuration use some behavior of Logrus Mate. sample | Testing Logrus has a built-in facility for asserting the presence of log messages. This is implemented through the hook and provides: decorators for existing logger and which basically just adds the hook a test logger that just records log messages and does not output any: Fatal handlers Logrus can register one or more functions that will be called when any level message is logged. The registered handlers will be executed before logrus performs an . This behavior may be helpful if callers need to gracefully shut down. Unlike a call which can be intercepted with a deferred a call to can not be intercepted. Thread safety By default, Logger is protected by a mutex for concurrent writes. The mutex is held when calling hooks and writing logs. If you are sure such locking is not needed, you can call logger.SetNoLock to disable the locking. Situations when locking is not needed include: You have no hooks registered, or hooks calling is already thread-safe. Writing to logger.Out is already thread-safe, for example: 1 logger.Out is protected by locks. 2 logger.Out is an os.File handler opened with flag, and every write is smaller than 4k. This allows multi-thread/multi-process writing Refer to http://www.notthewizard.com/2014/06/17/are-files-appends-really-atomic/