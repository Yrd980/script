12-Factor Agents - Principles for building reliable LLM applications <div align="center"> <a href="https://www.apache.org/licenses/LICENSE-2.0"> <img src="https://img.shields.io/badge/Code-Apache%202.0-blue.svg" alt="Code License: Apache 2.0"></a> <a href="https://creativecommons.org/licenses/by-sa/4.0/"> <img src="https://img.shields.io/badge/Content-CC%20BY--SA%204.0-lightgrey.svg" alt="Content License: CC BY-SA 4.0"></a> <a href="https://humanlayer.dev/discord"> <img src="https://img.shields.io/badge/chat-discord-5865F2" alt="Discord Server"></a> <a href="https://www.youtube.com/watch?v=8kMaTybvDUw"> <img src="https://img.shields.io/badge/aidotengineer-conftalk17m-white" alt="YouTube Deep Dive"></a> <a href="https://www.youtube.com/watch?v=yxJDyQ8v6P0"> <img src="https://img.shields.io/badge/youtube-deepdive-crimson" alt="YouTube Deep Dive"></a> </div> <p></p> In the spirit of 12 Factor Apps. The source for this project is public at https://github.com/humanlayer/12-factor-agents, and I welcome your feedback and contributions. Let's figure this out together! > !TIP > Missed the AI Engineer World's Fair? Catch the talk here > > Looking for Context Engineering? Jump straight to factor 3 > > Want to contribute to - check out the discussion thread <img referrerpolicy="no-referrer-when-downgrade" src="https://static.scarf.sh/a.png?x-pxid=2acad99a-c2d9-48df-86f5-9ca8061b7bf9" /> <a href="visual-nav"><img width="907" alt="Screenshot 2025-04-03 at 2 49 07 PM" src="https://github.com/user-attachments/assets/23286ad8-7bef-4902-b371-88ff6a22e998" /></a> Hi, I'm Dex. I've been hacking on AI agents for a while. I've tried every agent framework out there, from the plug-and-play crew/langchains to the "minimalist" smolagents of the world to the "production grade" langraph, griptape, etc. I've talked to a lot of really strong founders, in and out of YC, who are all building really impressive things with AI. Most of them are rolling the stack themselves. I don't see a lot of frameworks in production customer-facing agents. I've been surprised to find that most of the products out there billing themselves as "AI Agents" are not all that agentic. A lot of them are mostly deterministic code, with LLM steps sprinkled in at just the right points to make the experience truly magical. Agents, at least the good ones, don't follow the "here's your prompt, here's a bag of tools, loop until you hit the goal" pattern. Rather, they are comprised of mostly just software. So, I set out to answer: > What are the principles we can use to build LLM-powered software that is actually good enough to put in the hands of production customers? Welcome to 12-factor agents. As every Chicago mayor since Daley has consistently plastered all over the city's major airports, we're glad you're here. Special thanks to @iantbutler01, @tnm, @hellovai, @stantonk, @balanceiskey, @AdjectiveAllison, @pfbyjy, @a-churchill, and the SF MLOps community for early feedback on this guide. The Short Version: The 12 Factors Even if LLMs continue to get exponentially more powerful, there will be core engineering techniques that make LLM-powered software more reliable, more scalable, and easier to maintain. - How We Got Here: A Brief History of Software - Factor 1: Natural Language to Tool Calls - Factor 2: Own your prompts - Factor 3: Own your context window - Factor 4: Tools are just structured outputs - Factor 5: Unify execution state and business state - Factor 6: Launch/Pause/Resume with simple APIs - Factor 7: Contact humans with tool calls - Factor 8: Own your control flow - Factor 9: Compact Errors into Context Window - Factor 10: Small, Focused Agents - Factor 11: Trigger from anywhere, meet users where they are - Factor 12: Make your agent a stateless reducer Visual Nav | | | | |----|----|-----| |!factor 1https://github.com/humanlayer/12-factor-agents/blob/main/content/factor-01-natural-language-to-tool-calls.md | !factor 2https://github.com/humanlayer/12-factor-agents/blob/main/content/factor-02-own-your-prompts.md | !factor 3https://github.com/humanlayer/12-factor-agents/blob/main/content/factor-03-own-your-context-window.md | |!factor 4https://github.com/humanlayer/12-factor-agents/blob/main/content/factor-04-tools-are-structured-outputs.md | !factor 5https://github.com/humanlayer/12-factor-agents/blob/main/content/factor-05-unify-execution-state.md | !factor 6https://github.com/humanlayer/12-factor-agents/blob/main/content/factor-06-launch-pause-resume.md | | !factor 7https://github.com/humanlayer/12-factor-agents/blob/main/content/factor-07-contact-humans-with-tools.md | !factor 8https://github.com/humanlayer/12-factor-agents/blob/main/content/factor-08-own-your-control-flow.md | !factor 9https://github.com/humanlayer/12-factor-agents/blob/main/content/factor-09-compact-errors.md | | !factor 10https://github.com/humanlayer/12-factor-agents/blob/main/content/factor-10-small-focused-agents.md | !factor 11https://github.com/humanlayer/12-factor-agents/blob/main/content/factor-11-trigger-from-anywhere.md | !factor 12https://github.com/humanlayer/12-factor-agents/blob/main/content/factor-12-stateless-reducer.md | How we got here For a deeper dive on my agent journey and what led us here, check out A Brief History of Software - a quick summary here: The promise of agents We're gonna talk a lot about Directed Graphs DGs and their Acyclic friends, DAGs. I'll start by pointing out that...well...software is a directed graph. There's a reason we used to represent programs as flow charts. !010-software-dag From code to DAGs Around 20 years ago, we started to see DAG orchestrators become popular. We're talking classics like Airflow, Prefect, some predecessors, and some newer ones like dagster, inggest, windmill. These followed the same graph pattern, with the added benefit of observability, modularity, retries, administration, etc. !015-dag-orchestrators The promise of agents I'm not the first person to say this, but my biggest takeaway when I started learning about agents, was that you get to throw the DAG away. Instead of software engineers coding each step and edge case, you can give the agent a goal and a set of transitions: !025-agent-dag And let the LLM make decisions in real time to figure out the path !026-agent-dag-lines The promise here is that you write less software, you just give the LLM the "edges" of the graph and let it figure out the nodes. You can recover from errors, you can write less code, and you may find that LLMs find novel solutions to problems. Agents as loops As we'll see later, it turns out this doesn't quite work. Let's dive one step deeper - with agents you've got this loop consisting of 3 steps: 1. LLM determines the next step in the workflow, outputting structured json "tool calling" 2. Deterministic code executes the tool call 3. The result is appended to the context window 4. Repeat until the next step is determined to be "done" Our initial context is just the starting event maybe a user message, maybe a cron fired, maybe a webhook, etc, and we ask the llm to choose the next step tool or to determine that we're done. Here's a multi-step example: !027-agent-loop-animationhttps://github.com/user-attachments/assets/3beb0966-fdb1-4c12-a47f-ed4e8240f8fd <details> <summary><a href="https://github.com/humanlayer/12-factor-agents/blob/main/img/027-agent-loop-animation.gif">GIF Version</a></summary> !027-agent-loop-animation </details> Why 12-factor agents? At the end of the day, this approach just doesn't work as well as we want it to. In building HumanLayer, I've talked to at least 100 SaaS builders mostly technical founders looking to make their existing product more agentic. The journey usually goes something like: 1. Decide you want to build an agent 2. Product design, UX mapping, what problems to solve 3. Want to move fast, so grab $FRAMEWORK and get to building 4. Get to 70-80% quality bar 5. Realize that 80% isn't good enough for most customer-facing features 6. Realize that getting past 80% requires reverse-engineering the framework, prompts, flow, etc. 7. Start over from scratch <details> <summary>Random Disclaimers</summary> DISCLAIMER: I'm not sure the exact right place to say this, but here seems as good as any: this in BY NO MEANS meant to be a dig on either the many frameworks out there, or the pretty dang smart people who work on them. They enable incredible things and have accelerated the AI ecosystem. I hope that one outcome of this post is that agent framework builders can learn from the journeys of myself and others, and make frameworks even better. Especially for builders who want to move fast but need deep control. DISCLAIMER 2: I'm not going to talk about MCP. I'm sure you can see where it fits in. DISCLAIMER 3: I'm using mostly typescript, for reasons but all this stuff works in python or any other language you prefer. Anyways back to the thing... </details> Design Patterns for great LLM applications After digging through hundreds of AI libriaries and working with dozens of founders, my instinct is this: 1. There are some core things that make agents great 2. Going all in on a framework and building what is essentially a greenfield rewrite may be counter-productive 3. There are some core principles that make agents great, and you will get most/all of them if you pull in a framework 4. BUT, the fastest way I've seen for builders to get high-quality AI software in the hands of customers is to take small, modular concepts from agent building, and incorporate them into their existing product 5. These modular concepts from agents can be defined and applied by most skilled software engineers, even if they don't have an AI background > The fastest way I've seen for builders to get good AI software in the hands of customers is to take small, modular concepts from agent building, and incorporate them into their existing product The 12 Factors again - How We Got Here: A Brief History of Software - Factor 1: Natural Language to Tool Calls - Factor 2: Own your prompts - Factor 3: Own your context window - Factor 4: Tools are just structured outputs - Factor 5: Unify execution state and business state - Factor 6: Launch/Pause/Resume with simple APIs - Factor 7: Contact humans with tool calls - Factor 8: Own your control flow - Factor 9: Compact Errors into Context Window - Factor 10: Small, Focused Agents - Factor 11: Trigger from anywhere, meet users where they are - Factor 12: Make your agent a stateless reducer Honorable Mentions / other advice - Factor 13: Pre-fetch all the context you might need Related Resources - Contribute to this guide here - I talked about a lot of this on an episode of the Tool Use podcast in March 2025 - I write about some of this stuff at The Outer Loop - I do webinars about Maximizing LLM Performance with @hellovai - We build OSS agents with this methodology under got-agents/agents - We ignored all our own advice and built a framework for running distributed agents in kubernetes - Other links from this guide: - 12 Factor Apps - Building Effective Agents Anthropic - Prompts are Functions - Library patterns: Why frameworks are evil - The Wrong Abstraction - Mailcrew Agent - Mailcrew Demo Video - Chainlit Demo - TypeScript for LLMs - Schema Aligned Parsing - Function Calling vs Structured Outputs vs JSON Mode - BAML on GitHub - OpenAI JSON vs Function Calling - Outer Loop Agents - Airflow - Prefect - Dagster - Inngest - Windmill - The AI Agent Index MIT - NotebookLM on Finding Model Capability Boundaries Contributors Thanks to everyone who has contributed to 12-factor agents! <img src="https://avatars.githubusercontent.com/u/3730605?v=4&s=80" width="80px" alt="dexhorthy" /> <img src="https://avatars.githubusercontent.com/u/50557586?v=4&s=80" width="80px" alt="Sypherd" /> <img src="https://avatars.githubusercontent.com/u/66259401?v=4&s=80" width="80px" alt="tofaramususa" /> <img src="https://avatars.githubusercontent.com/u/18105223?v=4&s=80" width="80px" alt="a-churchill" /> <img src="https://avatars.githubusercontent.com/u/4084885?v=4&s=80" width="80px" alt="Elijas" /> <img src="https://avatars.githubusercontent.com/u/39267118?v=4&s=80" width="80px" alt="hugolmn" /> <img src="https://avatars.githubusercontent.com/u/1882972?v=4&s=80" width="80px" alt="jeremypeters" /> <img src="https://avatars.githubusercontent.com/u/380402?v=4&s=80" width="80px" alt="kndl" /> <img src="https://avatars.githubusercontent.com/u/16674643?v=4&s=80" width="80px" alt="maciejkos" /> <img src="https://avatars.githubusercontent.com/u/85041180?v=4&s=80" width="80px" alt="pfbyjy" /> <img src="https://avatars.githubusercontent.com/u/36044389?v=4&s=80" width="80px" alt="0xRaduan" /> <img src="https://avatars.githubusercontent.com/u/7169731?v=4&s=80" width="80px" alt="zyuanlim" /> <img src="https://avatars.githubusercontent.com/u/15862501?v=4&s=80" width="80px" alt="lombardo-chcg" /> <img src="https://avatars.githubusercontent.com/u/160066852?v=4&s=80" width="80px" alt="sahanatvessel" /> Versions This is the current version of 12-factor agents, version 1.0. There is a draft of version 1.1 on the v1.1 branch. There are a few Issues to track work on v1.1. License All content and images are licensed under a <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0 License</a> Code is licensed under the <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache 2.0 License</a>