fd !CICDhttps://github.com/sharkdp/fd/actions/workflows/CICD.yml !Version infohttps://crates.io/crates/fd-find 中文 한국어 is a program to find entries in your filesystem. It is a simple, fast and user-friendly alternative to https://www.gnu.org/software/findutils/. While it does not aim to support all of 's powerful functionality, it provides sensible opinionated defaults for a majority of use cases. Installation • How to use • Troubleshooting Features Intuitive syntax: instead of . Regular expression default and glob-based patterns. Very fast due to parallelized directory traversal. Uses colors to highlight different file types same as . Supports parallel command execution Smart case: the search is case-insensitive by default. It switches to case-sensitive if the pattern contains an uppercase character\. Ignores hidden directories and files, by default. Ignores patterns from your , by default. The command name is 50% shorter\ than :-. Demo !Demo How to use First, to get an overview of all available command line options, you can either run command-line-options for a concise help message or for a more detailed version. Simple search fd is designed to find entries in your filesystem. The most basic search you can perform is to run fd with a single argument: the search pattern. For example, assume that you want to find an old script of yours the name included : If called with just a single argument like this, fd searches the current directory recursively for any entries that contain the pattern . Regular expression search The search pattern is treated as a regular expression. Here, we search for entries that start with and end with : The regular expression syntax used by is documented here. Specifying the root directory If we want to search a specific directory, it can be given as a second argument to fd: List all files, recursively fd can be called with no arguments. This is very useful to get a quick overview of all entries in the current directory, recursively similar to : If you want to use this functionality to list all files in a given directory, you have to use a catch-all pattern such as or : Searching for a particular file extension Often, we are interested in all files of a particular type. This can be done with the or option. Here, we search for all Markdown files in the fd repository: The option can be used in combination with a search pattern: Searching for a particular file name To find files with exactly the provided search pattern, use the or option: Hidden and ignored files By default, fd does not search hidden directories and does not show hidden files in the search results. To disable this behavior, we can use the or option: If we work in a directory that is a Git repository or includes Git repositories, fd does not search folders and does not show files that match one of the patterns. To disable this behavior, we can use the or option: To really search all files and directories, simply combine the hidden and ignore features to show everything or use /. Matching the full path By default, fd only matches the filename of each file. However, using the or option, you can match against the full path. Command execution Instead of just showing the search results, you often want to do something with them. provides two ways to execute external commands for each of your search results: The / option runs an external command for each of the search results in parallel. The / option launches the external command once, with all search results as arguments. Examples Recursively find all zip archives and unpack them: If there are two such files, and , this would execute and . The two processes run in parallel if the files are found fast enough. Find all and files and auto-format them inplace with : Note how the option to can be passed as a separate argument. This is why we put the option last. Find all files and open them in your favorite editor: Note that we use capital here to open a single instance. If there are two such files, and , this will run . To see details like file permissions, owners, file sizes etc., you can tell to show them by running for each result: This pattern is so useful that provides a shortcut. You can use the / option to execute in this way: . The option is also useful when combining with ripgrep in order to search within a certain class of files, like all C++ source files: Convert all files to files: Here, is a placeholder for the search result. is the same, without the file extension. See below for more details on the placeholder syntax. The terminal output of commands run from parallel threads using will not be interlaced or garbled, so can be used to rudimentarily parallelize a task run over many files. An example of this is calculating the checksum of each individual file within a directory. Placeholder syntax The and options take a command template as a series of arguments instead of a single string. If you want to add additional options to after the command template, you can terminate it with a . The syntax for generating commands is similar to that of GNU Parallel: - : A placeholder token that will be replaced with the path of the search result . - : Like , but without the file extension . - : A placeholder that will be replaced by the basename of the search result . - : The parent of the discovered path . - : The basename, with the extension removed . If you do not include a placeholder, fd automatically adds a at the end. Parallel vs. serial execution For /, you can control the number of parallel jobs by using the / option. Use for serial execution. Excluding specific files or directories Sometimes we want to ignore search results from a specific subdirectory. For example, we might want to search all hidden files and directories but exclude all matches from directories. We can use the or option for this. It takes an arbitrary glob pattern as an argument: We can also use this to skip mounted directories: .. or to skip certain file types: To make exclude-patterns like these permanent, you can create a file. They work like files, but are specific to . For example: > !NOTE > also supports files that are used by other programs such as or . If you want to ignore these patterns globally, you can put them in 's global ignore file. This is usually located in in macOS or Linux, and in Windows. You may wish to include in your file so that directories, and their contents are not included in output if you use the option. Deleting files You can use to remove all files and directories that are matched by your search pattern. If you only want to remove files, you can use the / option to call . For example, to recursively remove all files, run: If you are unsure, always call without first. Alternatively, use s "interactive" option: If you also want to remove a certain class of directories, you can use the same technique. You will have to use s / flag to remove directories. > !NOTE > There are scenarios where using can cause race conditions: if you have a path like and want to remove all directories named , you can end up in a situation where the outer directory is removed first, leading to harmless "'foo/bar/foo': No such file or directory" errors in the call. Command-line options This is the output of . To see the full set of command-line options, use which also includes a much more detailed help text. Note that options can be given after the pattern and/or path as well. Benchmark Let's search my home folder for files that end in . It contains ~750.000 subdirectories and about a 4 million files. For averaging and statistical analysis, I'm using hyperfine. The following benchmarks are performed with a "warm"/pre-filled disk-cache results for a "cold" disk-cache show the same trends. Let's start with : is much faster if it does not need to perform a regular-expression search: Now let's try the same for . Note that performs a regular expression search by default. The options / option is needed here for a fair comparison. Otherwise does not have to traverse hidden folders and ignored paths see below: For this particular example, is approximately 23 times faster than and about 13 times faster than . By the way, both tools found the exact same 546 files :smile:. Note: This is one particular benchmark on one particular machine. While we have performed a lot of different tests and found consistent results, things might be different for you! We encourage everyone to try it out on their own. See this repository for all necessary scripts. Concerning fd's speed, a lot of credit goes to the and crates that are also used in ripgrep check it out!. Troubleshooting does not find my file! Remember that ignores hidden directories and files by default. It also ignores patterns from files. If you want to make sure to find absolutely every possible file, always use the options / option or to enable hidden and ignored files: Also remember that by default, only searches based on the filename and doesn't compare the pattern to the full path. If you want to search based on the full path similar to the option of you need to use the or option. Colorized output can colorize files by extension, just like . In order for this to work, the environment variable https://linux.die.net/man/5/dircolors has to be set. Typically, the value of this variable is set by the command which provides a convenient configuration format to define colors for different file formats. On most distributions, should be set already. If you are on Windows or if you are looking for alternative, more complete or more colorful variants, see here, here or here. also honors the https://no-color.org/ environment variable. doesn't seem to interpret my regex pattern correctly A lot of special regex characters like , , , .. are also special characters in your shell. If in doubt, always make sure to put single quotes around the regex pattern: If your pattern starts with a dash, you have to add to signal the end of command line options. Otherwise, the pattern will be interpreted as a command-line option. Alternatively, use a character class with a single hyphen character: "Command not found" for es or shell functions Shell es and shell functions can not be used for command execution via or . In , you can make the alias global via . In , you can use to make available to child processes. You would still need to call . For other use cases or shells, use a temporary shell script. Integration with other programs Using fd with You can use fd to generate input for the command-line fuzzy finder fzf: Then, you can type on your terminal to open fzf and search through the fd-results. Alternatively, you might like to follow symbolic links and include hidden files but exclude folders: You can even use fd's colored output inside fzf by setting: For more details, see the Tips section of the fzf README. Using fd with rofi is a graphical launch menu application that is able to create menus by reading from stdin. Piping output into s mode creates fuzzy-searchable lists of files and directories. Example Create a case-insensitive searchable multi-select list of PDF files under your directory and open the selection with your configured PDF viewer. To list all file types, drop the argument. To modify the list that is presented by rofi, add arguments to the command. To modify the search behaviour of rofi, add arguments to the command. Using fd with The emacs package find-file-in-project can use fd to find files. After installing , add the line to your or file. In emacs, run to find matching files. Alternatively, run to list all available files in the project. Printing the output as a tree To format the output of as a file-tree you can use the command with : This can be more useful than running by itself because does not ignore any files by default, nor does it support as rich a set of options as does to control what to print: On bash and similar you can simply create an alias: Using fd with or Note that has a builtin feature for command execution with its / and / options. If you prefer, you can still use it in combination with : Here, the option tells fd to separate search results by the NULL character instead of newlines. In the same way, the option of tells it to read the input in this way. Installation !Packaging statushttps://repology.org/project/fd-find/versions On Ubuntu ... and other Debian-based Linux distributions. If you run Ubuntu 19.04 Disco Dingo or newer, you can install the officially maintained package: Note that the binary is called as the binary name is already used by another package. It is recommended that after installation, you add a link to by executing command , in order to use in the same way as in this documentation. Make sure that is in your . If you use an older version of Ubuntu, you can download the latest package from the release page and install it via: Note that the .deb packages on the release page for this project still name the executable . On Debian If you run Debian Buster or newer, you can install the officially maintained Debian package: Note that the binary is called as the binary name is already used by another package. It is recommended that after installation, you add a link to by executing command , in order to use in the same way as in this documentation. Make sure that is in your . Note that the .deb packages on the release page for this project still name the executable . On Fedora Starting with Fedora 28, you can install from the official package sources: On Alpine Linux You can install the fd package from the official sources, provided you have the appropriate repository enabled: On Arch Linux You can install the fd package from the official repos: You can also install fd from the AUR. On Gentoo Linux You can use the fd ebuild from the official repo: On openSUSE Linux You can install the fd package from the official repo: On Void Linux You can install via xbps-install: On ALT Linux You can install the fd package from the official repo: On Solus You can install the fd package from the official repo: On RedHat Enterprise Linux RHEL 8/9/10, Almalinux 8/9/10, EuroLinux 8/9 or Rocky Linux 8/9/10 You can install the package from Fedora Copr. A different version using the slower malloc instead of jemalloc is also available from the EPEL8/9 repo as the package . On macOS You can install with Homebrew: … or with MacPorts: On Windows You can download pre-built binaries from the release page. Alternatively, you can install via Scoop: Or via Chocolatey: Or via Winget: On GuixOS You can install the fd package from the official repo: On NixOS / via Nix You can use the Nix package manager to install : Via Flox You can use Flox to install into a Flox environment: On FreeBSD You can install the fd-find package from the official repo: From npm On Linux and macOS, you can install the fd-find package: From source With Rust's package manager cargo, you can install fd via: Note that rust version 1.77.2 or later is required. is also needed for the build. From binaries The release page includes precompiled binaries for Linux, macOS and Windows. Statically-linked binaries are also available: look for archives with in the file name. Development Maintainers - sharkdp - tmccombs - tavianator License is distributed under the terms of both the MIT License and the Apache License 2.0. See the LICENSE-APACHE and LICENSE-MIT files for license details.