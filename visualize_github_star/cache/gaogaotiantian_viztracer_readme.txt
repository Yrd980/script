VizTracer !buildhttps://github.com/gaogaotiantian/viztracer/actions?query=workflow%3Abuild !flake8https://github.com/gaogaotiantian/viztracer/actions?query=workflow%3ALint !readthedocshttps://viztracer.readthedocs.io/en/stable/ !coveragehttps://codecov.io/gh/gaogaotiantian/viztracer !pypihttps://pypi.org/project/viztracer/ !Visual Studio Marketplace Versionhttps://marketplace.visualstudio.com/items?itemName=gaogaotiantian.viztracer-vscode !support-versionhttps://img.shields.io/pypi/pyversions/viztracer !licensehttps://github.com/gaogaotiantian/viztracer/blob/master/LICENSE !commithttps://github.com/gaogaotiantian/viztracer/commits/master !sponsorhttps://github.com/sponsors/gaogaotiantian VizTracer is a low-overhead logging/debugging/profiling tool that can trace and visualize your python code execution. The front-end UI is powered by Perfetto. Use "AWSD" to zoom/navigate. More help can be found in "Support - Controls". !exampleimghttps://github.com/gaogaotiantian/viztracer/blob/master/img/example.png Highlights Detailed function entry/exit information on timeline with source code Super easy to use, no source code change for most features, no package dependency Low overhead, probably the fastest tracer in the market Supports threading, multiprocessing, subprocess, async and PyTorch Powerful front-end, able to render GB-level trace smoothly Works on Linux/MacOS/Windows Install The preferred way to install VizTracer is via pip Basic Usage Command Line <details> <summary> A <code>result.json</code> file will be generated, which you can open with <code>vizviewer</code> </summary> vizviewer will host an HTTP server on torch.profiler to notice VizTracer about the thread to trace it. !exampleimghttps://github.com/gaogaotiantian/viztracer/blob/master/img/multithreadexample.png Refer to multi thread docs for details Multi Process Support VizTracer supports , , , , and out of the box. For more general multi-process cases, VizTracer can support with some extra steps. !exampleimghttps://github.com/gaogaotiantian/viztracer/blob/master/img/multiprocessexample.png Refer to multi process docs for details Async Support VizTracer supports natively, but could enhance the report by using . !exampleimghttps://github.com/gaogaotiantian/viztracer/blob/master/img/asyncexample.png Refer to async docs for details Flamegraph Perfetto supports native flamegraph, just select slices on the UI and choose "Slice Flamegraph". !exampleimghttps://github.com/gaogaotiantian/viztracer/blob/master/img/flamegraph.png Remote attach VizTracer supports remote attach to an arbitrary Python process to trace it, as long as viztracer is importable Refer to remote attach docs JSON alternative VizTracer needs to dump the internal data to json format. It is recommended for the users to install , which is much faster than the builtin library. VizTracer will try to import and fall back to the builtin library if does not exist. Performance VizTracer puts in a lot of effort to achieve low overhead. The actual performance impact largely depends on your application. For typical codebases, the overhead is expected to be below 1x. If your code has infrequent function calls, the overhead could be minimal. <details> <summary> Detailed explanation </summary> The overhead introduced by VizTracer is basically a fixed amount of time during function entry and exit, so the more time spent on function entries and exits, the more overhead will be observed. A pure recursive function could suffer 3x-4x overhead on Python3.11+ when the Python call is optimized, before that Python call was slower so the overhead ratio would be less. In the real life scenario, your code should not spend too much time on function calls they don't really do anything useful, so the overhead would be much smaller. Many techniques are applied to minimize the overall overhead during code execution to reduce the inevitable skew introduced by VizTracer the report saving part is not as critical. For example, VizTracer tries to use the CPU timestamp counter instead of a syscall to get the time when available. On Python 3.12+, VizTracer uses which has less overhead than . All of the efforts made it observably faster than , the Python stdlib profiler. However, VizTracer is a tracer, which means it has to record every single function entry and exit, so it can't be as fast as the sampling profilers - they are not the same thing. With the extra overhead, VizTracer provides a lot more information than normal sampling profilers. </details> Documentation For full documentation, please see https://viztracer.readthedocs.io/en/stable Bugs/Requests Please send bug reports and feature requests through github issue tracker. VizTracer is currently under development now and it's open to any constructive suggestions. License Copyright 2020-2025 Tian Gao. Distributed under the terms of the Apache 2.0 license.