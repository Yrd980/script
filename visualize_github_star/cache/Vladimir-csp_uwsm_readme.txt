Universal Wayland Session Manager Wraps standalone Wayland compositors into a set of Systemd units on the fly. This provides robust session management including environment, XDG autostart support, bi-directional binding with login session, and clean shutdown. For compositors this is an opportunity to offload Systemd integration and session/XDG autostart management in Systemd-managed environments. > !IMPORTANT > This project is currently in a stable phase with a slow-burning refactoring. > Although no drastic changes are planned, keep an eye for commits with breaking > changes, indicated by an exclamation point e.g. , , > , etc.. > !IMPORTANT > Some changes in v0.23.0: > - Compositor slice selection options are deprecated |, > and will be removed in future versions, > is always used. > - Basic unit files are now static by default build option > . > - Generated drop-in files can be managed in systemd > configuration rung option for and subcommands, > var. In future versions this will become the default > behavior when built with . It can shave off some > startup time by removing the need for systemd reload. > - Tweak drop-ins can be disabled option, var. > !NOTE > It is highly recommended to use > dbus-broker as the D-Bus daemon > implementation. Among other benefits, it reuses the systemd activation > environment instead of having a separate one. This simplifies environment > management and allows proper cleanup. Reference D-Bus implementation is also > supported, but it doesn't allow unsetting vars, so a best effort cleanup is > performed by setting them to an empty string instead. The only way to properly > clean up the separate environment of the reference D-Bus daemon is to run > . !uwsm select via whiptail Concepts and features <details><summary> Uses systemd units and dependencies for startup, operation, and shutdown. </summary> - Binds to the basic structure of , , . - Adds custom nested slices , , to put apps in and terminate them cleanly on exit. - Provides convenient way of launching apps into those slices. </details> <details><summary> Systemd units are treated with hierarchy and universality in mind. </summary> - Templated units with specifiers. - Named from common to specific where possible. - Allowing for high-level drop-ins. </details> <details><summary> Bi-directional binding between login session and graphical session. </summary> Using utility or a built-in shim together with native systemd mechanisms, uwsm binds lifetime of a login session system unit to graphical session a set of user units and vice versa. </details> <details><summary> Compositor-specific behavior is adjustable by plugins. </summary> Currently included: - - - - </details> <details><summary> Idempotently well, best-effort-idempotently handles environment. </summary> - On startup a specialized unit prepares environment by: - either loading environment context saved by command or sourcing shell profile by itself - sourcing , files from each dir of reversed sequence in increasing priority, where is each item of , lowercased - Difference between environment state before and after preparation is exported into systemd user manager and D-Bus activation environment if reference D-Bus implementation is used - On shutdown previously exported variables are unset from systemd user manager activation environment of reference D-Bus daemon does not support unsetting, so those vars are emptied instead ! - Lists of variables for export and cleanup are determined algorithmically by: - comparing environment before and after preparation procedures - boolean operations with predefined lists - manually exported vars by action </details> <details><summary> Can work with Desktop entries from in XDG data hierarchy and/or be included in them. </summary> - Actively select and launch compositor from Desktop entry which is used as compositor instance ID: - Data taken from entry can be amended or overridden via CLI arguments: - for argument list - for and - and for unit - Entries can be overridden, masked or added in - Optional interactive selector requires , choice is saved in , default is read from it, falling back all the way through - Desktop entry actions are supported - Be launched via a Desktop entry by a login/display manager. </details> <details><summary> Can run with arbitrary compositor command line, or take it along with other data from desktop entries saved as a unit drop-in. </summary> </details> <details><summary> Provides better control of XDG autostart apps. </summary> - XDG autostart services units are placed into that receives stop action before compositor is stopped. - Can be mass-controlled via stopping and starting </details> <details><summary> Tries best to shutdown session cleanly via a net of dependencies between units. </summary> Basic provided unit files can be transiet if project built with : Managed generated files in or depending on opton: Compositor metadata customization drop-ins: Tweaks for other units: See Longer story section below for descriptions. </details> <details><summary> Provides helpers and tools for various operations. </summary> - : for explicitly exporting variables to activation environments and signal compositor's unit readiness compositor service unit uses - : for checking conditions for launch at login for integration into login shell profile - : for launching applications as scopes or services in proper slices - desktop entries or plain executables are supported - support for launching a terminal/in terminal proposed xdg-terminal-exec - flexible unit metadata support - : a simple and fast shell client to app-daemon feature of uwsm, a drop-in replacement of . The daemon started on-demand handles finding requested desktop entries, parsing and generation of commands for client to execute. This avoids the overhead of repeated python startup and increases app launch speed. Intended for interactive launching, as it can fail on simultaneous requests. - : graphical via dmenu-like menus tool for managing user units. - : background service for notifying about failed units. </details> Installation and basic configuration 1. Building and installing Checkout the last version-tagged commit. Untagged commits are WIP. <details><summary> Building and installing the python project directly. </summary> The example enables optional tools , , and available in this project see helpers and tools spoiler in concepts section above. </details> <details><summary> Building and installing a deb package. </summary> Read and run Alternatively, </details> <details><summary> Arch. </summary> </details> <details><summary> NixOS options. </summary> Enable it using and configure available compositors using . Please see the options' descriptions for more information. </details> Runtime dependencies: - python modules: - xdg pyxdg - dbus dbuspython - optional, but recommended for resources; from or package - optional, for feature; from or package - a dmenu-like menu optional; for script, supported: - - - - - - - - - optional, for feedback from commands and optional failed unit monitor service; from or package 2. Service startup notification and vars set by compositor Potentially tricky part. TLDR; if your compositor puts and along with it , or other important or useful variables into systemd activation environment, uwsm will make everything work automagically, proceed to section 3. Otherwise configure compositor to run command at the end of its startup. It will deal with putting and if set variables into activation environments in the best possible ways and signal unit readiness to systemd. <details><summary> If compositor is known to set useful vars but they are missing from activation environments. </summary> List names of variable as arguments to , or append them to whitespace-separated list in variable do it beforehand, i.e. in env files or shell profile. Example snippet for sway config these vars are already covered by sway plugin via var and listed here just for clearness: Undefined variables will be are silently ignored. </details> <details><summary> If graphical session is reached prematurely, i.e. compositor puts other vars into activation environments much later than , too late for downstream units to get. </summary> Append names of variables to whitespace-separated list in variable do it beforehand, i.e. in env files or shell profile. This will make uwsm delay graphical session startup until those vars appear in the systemd activation environment. Depending on the situation, combine this with with command to put more variables into activation environments and gain more control over delay mechanism of uwsm. Be aware that skips undefined vars, so be sure that all vars listed in are really being set, or use explicit assignment to serve as a marker. Example: You can also tweak float, default: 0.2 to change pause duration after all expected vars are found. </details> <details><summary> Technical details </summary> Inside before executing compositor itself, uwsm forks a process that probes systemd activation environment for var and vars listed in variable whitespace-separated. When all expected vars appear, it pauses for seconds float, default: 0.2 and signals unit readiness. It also updates cleanup list with delta between states of activation environment at unit startup time and the end of settle pause. If classic D-Bus implementation is used, this delta is also synched to its activation environment. A separate unit, is launched alongside compositor, with similar ordering after , before . It also waits for the same variables in the same manner, then successfully exits or times out. Its job is to delay activation in case compositor signals its readiness prematurely. Or to fail startup if expected vars do not appear. The command fills systemd and D-Bus environments with essential vars set by the compositor: mandatory and if present. Optional vars are taken by name from arguments and var, which is also pre-filled by plugins. D-Bus implementation quirks are handled. Undefined vars are silently ignored. Any exported variables are also added to cleanup list. Timeout for unit startup is 10 seconds. </details> 3. Applications and Slices Applications should be launched in their own user-level systemd units. Some applications usually those intended to be autostarted in a graphical session are shipped with their own units. Check and enable them with: . <details><summary> More info </summary> if it provides if it does not In the end autostarted unit should have both dependency and ordering be wanted by a target and ordered after it see example-units. Or just start with . Units can be fully or partially overridden/edited via standard systemd mechanisms. </details> Other apps are shipped with XDG autostart entries. Systemd automatically converts them to units and starts. <details><summary> More info </summary> Their / lists should align with items or be absent. Autostart entries can be overridden by copying and editing them in . Generated units are editable via drop-ins. Also see example-units and refer to Desktop Application Autostart Specification </details> To launch any other app use: A one-shot app launcher can be started directly, but either configured to run things via or wrapped in a shell expression to handle output. Not all launchers are able to provide Desktop Entry ID, most just provide the resulting command, so units will lack fancy description. Some examples: | Launcher | Via | What | Entry | | -------- | ------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----- | | fuzzel | command | | no | | fuzzel | config | | no | | albert | env var | : | no | | albert | shell | | no | | walker | config | | no | | wofi | shell | | yes | | wofi | shell | | yes | | tofi | shell | | no | | rofi | command | | no | Compositor itself runs in which has priority in some resource allocation. It would be a bad practice to accumulate all apps there, and extremely bad practice to accumulate processes inside compositor's unit itself. <details><summary> Faster alternatives </summary> can be quite slow on some setups due to repeated python startup overhead. Included optional script uitilizes uwsm's on-demand app daemon for more responsiveness in interactive launching, but can fail on simultaneous requests. app2unit is a faster shell alternative, with feature parity. It can also be used outside uwsm environment and can integrate with Fuzzel. runapp a fast C++ executable, although it is not feature-complete yet. </details> <details><summary> Background and details </summary> launches the compositor's service as in . Processes descendent from the compositor will be a part of its unit which might be mostly OK for short-lived one-off commands, i.e. volume adjustment. But processes inside comopositor's unit will have brief access to its notification socket before it is restricted after startup is complete. This may lead to unforeseen consequences, like compositor unit being erroneously declared entering stopping state. Systemd documentation recommends launching apps as their own units scopes or services. would be the default destination, and are available for low-priority non-interactive tasks and high-prioirity responsiveness-aware tasks respectively, see provides a convenient way of handling this: special nested slices that will also receive stop action before shutdown: - default destination - - units of XDG autostart entries are also modified to be started in . To launch an app inside one of those slices, use: Launching desktop entries via a valid ID is also supported optionally with an action ID appended via : In this case args must be supported by the entry or its selected action according to the XDG Desktop Entry Specification. Specifying paths to executables or desktop entry files is also supported. Always use to disambiguate command line if any dashed arguments are intended for the app being launched. Scopes are the default type of units for launching apps via , they are executed in-place and behave like simple commands, inheriting environment and pty of origin. Services are launched in the background by the systemd user manager and are given an environment based on the current state of the activation environment of systemd; their output is routed to the journal. will return immediately after launch. This allows more control over the application, i.e. restarting it with an updated environment. Example snippets for sway config for launching apps: Launch proposed default terminal: Fuzzel has a very handy launch-prefix option: Walker can prefix launching apps by setting variable in the config, so . Launch SpaceFM via a desktop entry: Featherpad desktop entry has "standalone-window" action: Unit type of launched apps can be controlled by argument or setting its default via env var. </details> 4. Environments and shell profile There are three general groups of environment variables in graphical session operation: - those that all/some apps need to see - those that compositor needs to see - those that compositor sets and graphical apps need to see this was covered in section 2 Summary of where to put a user-level var for the first two categories: - For user's systemd services, including compositor: define in . It does not affect login sessions or systemd user manager itself see . - For login shell context and uwsm environment preloader, including plugins: export in your shell's profile. - For uwsm-managed graphical session: export in - For uwsm-managed graphical session of specific compositor: export in Choose whatever scope suits your needs. If startup was initiated via command, its environment will be saved and picked up by environment preloader since is supposed to be started from login session context, it is assumed that profile of the login shell was already sourced. Otherwise, environment preloader will source POSIX shell profile by itself , . Other shells compatibility with these files may vary. Operation Syntax and behavior option is available for and all of its subcommands. Basics: Always use to disambiguate command line if any dashed arguments are intended for the launched compositor. can be an executable or a valid desktop entry ID optionally with an action ID appended via '', or one of special the values: . If is given as a path, or option is given, "hardcode" mode is engaged: the resulting command line will always be written to unit drop-ins and contain full path to executable as seen by . Path to executable will also be written if encountered in a desktop entry's . Optional parameters to provide more metadata: - : append or exclusively set - - Arguments and metadata are stored in specifier unit drop-ins if needed. The command will wait until the graphical session ends, also holding open the login session it resides in. The graphical session will also deactivate if the process that started it ends. <details><summary> Some details </summary> If is a desktop entry ID, will find it in data hierarchy. will be used for command line, and will fill , and will go to units' description. Arguments provided on the command line are appended to the command line from session's desktop entry unlike application entries; no argument processing is done. Please file a bug report if you encounter any desktop entry with -fields which would require this behavior to be altered. If you want to customize compositor execution provided with a desktop entry, copy it to and change to your liking, including adding actions. If is or , invokes a menu to select desktop entries available in data hierarchy including their actions. Selection is saved, previous selection is highlighted or launched right away in case of . Selected entry is used as instance ID. There is also a separate action that only selects and saves default and does nothing else, which is handy for seamless shell profile integration. will also wait for activation of system and either warn or abort if timed out, or if was not found in queue. This behavior can be controlled via option. It can not however stop automatically if system becomes deactivated. Things will do: - Prepare unit drop-ins for metadata and tweaks in runtime or home directory. - Fork a process protected from and signals that will find future compositor unit's and wait for it to end, ensuring login session is kept open until graphical session ends. - Start unit pointing to 's own PID to rig graphical session shutdown in case or login session ends. - Finally, replace itself with command which will actually start the compositor unit and wait while wayland session is running. </details> Where to launch from Shell profile integration To launch automatically after login on virtual console 1, if systemd is at , add this code or equivalent to your shell's profile: The main statement should be protected by a condition that will return false in situations when running is not desired. I.e. if this is and uwsm environment preloader sources it by itself it can do that if compositor's unit was activated without the use of command. subcommand serves as a collection of useful checks. By default: parent is a login shell process name starts with , tty1 is in foreground, system's is active or activating, user's and other related units are inactive. Also for convenience environment preloader defines variable not exported, which can be probed from shell profile to do things conditionally. shows whiptail menu to select the default desktop entry from directories. At this point one can cancel and continue with the normal login shell. in shell profile causes to replace login shell, binding it to user's login session. launches the previously selected default compositor. From a display manager To launch uwsm from a display/login manager, can be used inside desktop entries. Example : Things to keep in mind: - Command in should start with . - If command references an executable, keys of the entry should be mirrored in arguments, because otherwise will not have access to those strings. - It should not point to itself as a combination of Desktop Entry ID and Action ID. - It should not point to a Desktop Entry ID and Action ID that also uses . Potentially such entries may be found and used by itself, i.e. in shell profile integration situation, or when launched manually. Following the principles above ensures will properly recognize itself and parse requested arguments inside the entry without any side effects. Some display managers may fail to handle quoting correctly. Workaround in this case is to use single-word arguments and/or point to another entry. Alternatively, if a display manager supports wrapper commands/scripts, can be inserted there to receive either Entry and Action IDs, or a parsed command line. Testing and feedback is needed. How to stop Either of: - this ends all login sessions and units of current user, good for resetting everything, including runtime units, environments, etc. - this ends login session that uwsm was launched in, special unit waiting for the former login shell process will exit and bring down graphical session units. Empty argument will only work if is called from within login session scope itself, so variable should be used when calling from graphical session units - brings down graphical session units. Login session will end if replaced login shell - effectively the same as previous one Do not use compositor's native exit mechanism or kill its process directly, this will yank compositor from under all the clients and interfere with ordered unit deactivation sequence. Longer story, tour under the hood Some extended examples and partial recreation of some behaviors via excessive shell code, just for deeper explanation. <details><summary> Dive </summary> Start and bind Depending on build option, units files are provided or generated on the fly. Customization drop-ins are always generated if needed. Tweak drop-ins can be disabled by option. Run to populate conriguration with them and do nothing else . Destination rung can be or , depending on or option. Managed files in the other rung are removed. Any remainder arguments are appended to compositor argument list even when is a desktop entry. Use to disambiguate: Desktop entries can be overridden or added in . Basic set of unit files: - templated targets bound to stock systemd user-level targets - - - - templated services - - environment preloader service - - main compositor service - - fast app command generator - slices for apps nested in stock systemd user-level slices - - - - metadata drop-ins - , - if arguments and/or various names, path to executable were given on command line, they go here. - tweaks - - assigns XDG autostart apps to - - adds ordering to KDE desktop portal. - shutdown and cleanup units - - starts utility for a given PID. Invokes when deactivated. starts this unit pointing to itself just before replacing itself with unit startup command. - - conflicts with operational units. Triggered by deactivation of and units, both successful or failed. But can also be called manually for shutdown. After unit files are generated, compositor can be started by: But this would run it completely disconnected from a login session or any process that started it. To fix that use to track PID of login shell and stop graphical session when it exits: Add to hold the terminal until session ends, it to replace login shell with invocation reusing its PID: This makes the end of login shell also be the end of wayland session and vice versa. When is started during startup, is launched with shared set of custom arguments. It looks for environment saved by command, then runs shell code to prepare environment. The code sources POSIX shell profile if environment from was not found, files, anything that plugins dictate. Environment state at the end of shell code is given back to the main process. is also smart enough to find login session associated with current TTY and set , if it was not found in the context saved by . The difference between initial env that is the state of activation environment and after all the sourcing and setting is done, plus , minus , is added to activation environment of systemd user manager and D-Bus. Those variable names, plus minus are written to a cleanup list file in runtime dir. Startup finalization This step is not needed if compositor at least puts into systemd activation environment: uwsm will autodetect this and handle the rest. If something goes wrong, startup can be fixed by using combination of command and configuration variables , , uses and waits for compositor to signal started state. Activation environments will also need to receive essential variables like to launch graphical applications successfully. A forked process inside waits for and all vars mentioned in , then signals unit readiness and restricts notification socket access from to . It also appends variable cleanup list with any delta it has seen since unit startup. Separate does the same waiting thing and either exits successfully allowing to proceed, or times out, bringing everything down. can be run by compositor, essentially it performs actions analogous to: action equivalent is redundant for and is skipped automatically Additional variable names are taken from var. Only defined variables are used. Variables that are not blacklisted by set are also added to cleanup list in the runtime dir. Stop Just stop the main service: , everything else will be stopped by systemd. Wildcard will also work, as does stopping Or activate shutdown target: If an instance of is active and pointing to a PID in login session, any of the above stop commands also doubles as a logout command. When is stopped, is launched. It looks for any cleanup files in runtime dir. Listed variables, plus minus are emptied in D-Bus activation environment and unset from systemd user manager environment. When no compositor is running, units can be removed by . Add compositor to to remove only customization drop-ins: . Profile integration This example does the same thing as + subcommand combination described earlier: starts wayland session automatically upon login on tty1 if system is in Screening for being in interactive login shell here is essential . sources profile, which has a potential for nasty loops if run unconditionally. Other conditions are a recommendation: also has a mechanism that holds the login session open until the compositor unit is deactivated. It works by forking a process immune to and signals inside login session. This process finds compositor unit's and waits until it ends. This mechanism would be too complicated to replicate in shell for purposes of this demonstration. </details> Compositor-specific actions Shell plugins provide compositor-specific functions during environment preparation. Named , they should only contain specifically named functions. is derived from the item 0 of compositor command line by applying and converting to lower case. It is used as plugin id and suffix in function names. Variables available to plugins: - - compositor ID, effective first argument of . - - compositor ID escaped for systemd unit name. - - processed first item of compositor argv. - - -separated desktop names from of entry and CLI argument. - - first of the above. - - same as the above, but in lower case. - - first of the above. - - | indicates that came from CLI argument and are marked as exclusive. - - contains shell default field separator space, tab, newline for convenient restoring. Standard functions: - - standard function for loading env files - - called by , iterates over whole XDG Config and system XDG Data hierarchies decreasing priority - - called by for each config dir, does nothing ATM - - called by , same as , but in reverse increasing priority - - called by for each config dir, loads , files - - sources file, providing messages for log. See code inside for more auxiliary functions. Functions that can be added by plugins, replacing standard functions: - - called before env loading. - - - - - Original functions are still available for calling explicitly if combined effect is needed. Example: Compliments Inspired by and adapted some techniques from: - sway-services - sway-systemd - sway - Presentation by Martin Pitt Special thanks to: - @skewballfox for help with python and pointing me to useful tools. - @notpeelz for improving commit process, meson, modularization, creating AUR package. - @YaLTeR for an idea that lead to automatic compositor startup detection. - @izmyname for integration and documentation work on Hyprland's side.