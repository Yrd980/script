komorebi Tiling Window Management for Windows. <p> <a href="https://techforpalestine.org/learn-more"> <img alt="Tech for Palestine" src="https://badge.techforpalestine.org/default"> </a> <img alt="GitHub Workflow Status" src="https://img.shields.io/github/actions/workflow/status/LGUG2Z/komorebi/.github/workflows/windows.yaml"> <img alt="GitHub all releases" src="https://img.shields.io/github/downloads/LGUG2Z/komorebi/total"> <img alt="GitHub commits since latest release by date for a branch" src="https://img.shields.io/github/commits-since/LGUG2Z/komorebi/latest"> <img alt="Active Individual Commercial Use Licenses" src="https://img.shields.io/badge/dynamic/json?url=https%3A%2F%2Flgug2z-ecstaticmagentacheetah.web.val.run&query=%24.&label=active%20individual%20commercial%20use%20licenses&cacheSeconds=3600&link=https%3A%2F%2Flgug2z.com%2Fsoftware%2Fkomorebi"> <a href="https://discord.gg/mGkn66PHkx"> <img alt="Discord" src="https://img.shields.io/discord/898554690126630914"> </a> <a href="https://github.com/sponsors/LGUG2Z"> <img alt="GitHub Sponsors" src="https://img.shields.io/github/sponsors/LGUG2Z"> </a> <a href="https://ko-fi.com/lgug2z"> <img alt="Ko-fi" src="https://img.shields.io/badge/kofi-tip-green"> </a> <a href="https://notado.app/feeds/jado/software-development"> <img alt="Notado Feed" src="https://img.shields.io/badge/Notado-Subscribe-informational"> </a> <a href="https://www.youtube.com/channel/UCeai3-do-9O4MNy9xjO6mg?subconfirmation=1"> <img alt="YouTube" src="https://img.shields.io/youtube/channel/subscribers/UCeai3-do-9O4MNy9xjO6mg"> </a> </p> !screenshot Overview komorebi is a tiling window manager that works as an extension to Microsoft's Desktop Window Manager in Windows 10 and above. komorebi allows you to control application windows, virtual workspaces and display monitors with a CLI which can be used with third-party software such as https://github.com/LGUG2Z/whkd and AutoHotKey to set user-defined keyboard shortcuts. komorebi aims to make as few modifications as possible to the operating system and desktop environment by default. Users are free to make such modifications in their own configuration files for komorebi, but these will remain opt-in and off-by-default for the foreseeable future. Please refer to the documentation for instructions on how to install and configure komorebi, common workflows, a complete configuration schema reference and a complete CLI reference. Community There is a Discord server available for komorebi-related discussion, help, troubleshooting etc. If you have any specific feature requests or bugs to report, please create an issue in this repository. There is a YouTube channel where I post komorebi development videos, feature previews and release overviews. Subscribing to the channel which is monetized as part of the YouTube Partner Program and watching videos is a really simple and passive way to contribute financially to the development and maintenance of komorebi. There is an Awesome List which showcases the many awesome projects that exist in the komorebi ecosystem. Licensing for Personal Use is educational source software. is licensed under the Komorebi 2.0.0 license, which is a fork of the PolyForm Strict 1.0.0 license. On a high level this means that you are free to do whatever you want with for personal use other than redistribution, or distribution of new works i.e. hard-forks based on the software. Anyone is free to make their own fork of with changes intended either for personal use or for integration back upstream via pull requests. The Komorebi 2.0.0 License does not permit any kind of commercial use i.e. using at work. Sponsorship for Personal Use komorebi is a free and educational source project, and one that encourages you to make charitable donations if you find the software to be useful and have the financial means. I encourage you to make a charitable donation to the Palestine Children's Relief Fund or to contribute to a Gaza Funds campaign before you consider sponsoring me on GitHub. GitHub Sponsors is enabled for this project. Sponsors can claim custom roles on the Discord server, get shout outs at the end of komorebi-related videos on YouTube, gain the ability to submit feature requests on the issue tracker, and receive releases of komorebi with "easter eggs" on physical media. If you would like to tip or sponsor the project but are unable to use GitHub Sponsors, you may also sponsor through Ko-fi, or make an anonymous Bitcoin donation to . Licensing for Commercial Use A dedicated Individual Commercial Use License is available for those who want to use at work. The Individual Commerical Use License adds “Commercial Use” as a “Permitted Use” for the licensed individual only, for the duration of a valid paid license subscription only. All provisions and restrictions enumerated in the Komorebi License continue to apply. More information, pricing and purchase links for Individual Commercial Use Licenses can be found here. Installation A detailed installation and quickstart guide is available which shows how to get started using , or building from source. !Watch the quickstart walkthrough videohttps://www.youtube.com/watch?v=MMZUAtHbTYY Comparison With Fancy Zones Community member Olge has created an excellent video which compares the default window management features of Windows 11, Fancy Zones and komorebi. If you are not familiar with tiling window managers or if you are looking at komorebi and wondering "how is this different from Fancy Zones? 🤔", this short video will answer the majority of your questions. !Watch the comparison videohttps://www.youtube.com/watch?v=0LCbSgm0RA Demonstrations @amnweb showing komorebi running on Windows 11 with window borders, unfocused window transparency and animations enabled, using a custom status bar integrated using komorebi' s Window Manager Event Subscriptions. https://github.com/LGUG2Z/komorebi/assets/13164844/21be8dc4-fa76-4f70-9b37-1d316f4b40c2 @haxibami showing komorebi running on Windows 11 with a terminal emulator, a web browser and a code editor. The original video can be viewed here. https://user-images.githubusercontent.com/13164844/163496447-20c3ff0a-c5d8-40d1-9cc8-156c4cebf12e.mp4 @aik2mlj showing komorebi running on Windows 11 with multiple workspaces, terminal emulators, a web browser, and the yasb status bar with the komorebi workspace widget enabled. The original video can be viewed here. https://user-images.githubusercontent.com/13164844/163496414-a9cde3d1-b8a7-4a7a-96fb-a8985380bc70.mp4 Contribution Guidelines If you would like to contribute to please take the time to carefully read the guidelines below. Please see CONTRIBUTING.md for more information about how code contributions to are licensed. Commit hygiene - Flatten all statements - Run and ensure that all lints and suggestions have been addressed before committing - Run to ensure consistent formatting before committing - Use with the Commitizen CLI to prepare commit messages - Provide at least one short sentence or paragraph in your commit message body to describe your thought process for the changes being committed PRs should contain only a single feature or bug fix It is very difficult to review pull requests which touch multiple unrelated features and parts of the codebase. Please do not submit pull requests like this; you will be asked to separate them into smaller PRs that deal only with one feature or bug fix at a time. If you are working on multiple features and bug fixes, I suggest that you cut a branch called from which you keep up to date, and rebase the various independent branches you are working on onto that branch if you want to test them together or create a build with everything integrated. Refactors to the codebase must have prior approval is a mature codebase with an internal consistency and structure that has developed organically over close to half a decade. There are countless hours of live coding videos demonstrating work on this project and showing new contributors how to do everything from basic tasks like implementing new commands to distinguishing monitors by manufacturer hardware identifiers and video card ports. Refactors to the structure of the codebase are not taken lightly and require prior discussion and approval. Please do not start refactoring the codebase with the expectation of having your changes integrated until you receive an explicit approval or a request to do so. Similarly, when implementing features and bug fixes, please stick to the structure of the codebase as much as possible and do not take this as an opportunity to do some "refactoring along the way". It is extremely difficult to review PRs for features and bug fixes if they are lost in sweeping changes to the structure of the codebase. Breaking changes to user-facing interfaces are unacceptable This includes but is not limited to: - All commands - The schema - The schema No user should ever find that their configuration file has stopped working after upgrading to a new version of . More often than not there are ways to reformulate changes that may initially seem like they require breaking user-facing interfaces into additive changes. For some inspiration please take a look at this commit which added the ability for users to specify colours in in Hex format alongside RGB. There is also a process in place for graceful, non-breaking, deprecation of configuration options that are no longer required. Development If you use IntelliJ, you should enable the following settings to ensure that code generated by macros is recognised by the IDE for completions and navigation: - Set to under "Settings > Langauges & Frameworks > Rust" - Enable the following experimental features: - - Logs and Debugging Logs from will be appended to ; this file is never rotated or overwritten, so it will keep growing until it is deleted by the user. Whenever running the command or sending a Ctrl-C signal to directly, the process ensures that all hidden windows are restored before termination. If however, you ever end up with windows that are hidden and cannot be restored, a list of window handles known to are stored and continuously updated in . Restoring Windows Running will read the list of window handles and forcibly restore them, regardless of whether the main process is running. Panics and Deadlocks If ever stops responding, it is most likely either due to either a panic or a deadlock. In the case of a panic, this will be reported in the log. In the case of a deadlock, there will not be any errors in the log, but the process and the log will appear frozen. If you believe you have encountered a deadlock, you can compile with and try reproducing the deadlock again. This will check for deadlocks every 5 seconds in the background, and if a deadlock is found, information about it will appear in the log which can be shared when opening an issue. Window Manager State and Integrations The current state of the window manager can be queried using the command, which returns a JSON representation of the struct. This may also be polled to build further integrations and widgets on top of. Window Manager Event Subscriptions Named Pipes It is possible to subscribe to notifications of every and handled by using Named Pipes. First, your application must create a named pipe. Once the named pipe has been created, run the following command: Note that you do not have to include the full path of the named pipe, just the name. If the named pipe exists, will start pushing JSON data of successfully handled events and messages: You may then filter on the key to listen to the events that you are interested in. For a full list of possible notification types, refer to the enum variants of in and in . Below is an example of how you can subscribe to and filter on events using a named pipe in . Unix Domain Sockets It is possible to subscribe to notifications of every and handled by using Unix Domain Sockets. UDS are also the only mode of communication between and . First, your application must create a socket in . Once the socket has been created, run the following command: If the socket exists, komorebi will start pushing JSON data of successfully handled events and messages as in the example above in the Named Pipes section. Rust Client As of it is possible to use the crate to subscribe to notifications of every and handled by in a Rust codebase. Below is a simple example of how to use in a basic Rust application. A read-world example can be found in komokana. Subscription Event Notification Schema A JSON Schema of the event notifications emitted to subscribers can be generated with the command. The output of this command can be redirected to the clipboard or a file, which can be used with services such as Quicktype to generate type definitions in different programming languages. Communication over TCP A TCP listener can optionally be exposed on a port of your choosing with the flag. If this flag is not provided to or , no TCP listener will be created. Once created, your client may send any SocketMessage to in the same way that would. This can be used if you would like to create your own alternative to which incorporates scripting and various middleware layers, and similarly it can be used if you would like to integrate with a custom input handler. If a client sends an unrecognized message, it will be disconnected and have to reconnect before trying to communicate again. Socket Message Schema A JSON Schema of socket messages used to send instructions to can be generated with the command. The output of this command can be redirected to the clipboard or a file, which can be used with services such as Quicktype to generate type definitions in different programming languages. Appreciations - First and foremost, thank you to my wife, both for naming this project and for her patience throughout its never-ending development - Thank you to @sitiom for being an exemplary open source community leader - Thank you to the developers of nog who came before me and whose work taught me more than I can ever hope to repay - Thank you to the developers of GlazeWM for pushing the boundaries of tiling window management on Windows with me and having an excellent spirit of collaboration - Thank you to @Ciantic for helping me bring the hidden Virtual Desktops cloaking function to