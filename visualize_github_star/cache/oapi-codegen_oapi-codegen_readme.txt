!OpenSSF Best Practiceshttps://www.bestpractices.dev/projects/9450 is a command-line tool and library to convert OpenAPI specifications to Go code, be it server-side implementations, API clients, or simply HTTP models. Using allows you to reduce the boilerplate required to create or integrate with services based on OpenAPI 3.0, and instead focus on writing your business logic, and working on the real value-add for your organisation. With , there are a few Key Design Decisions we've made, including: - idiomatic Go, where possible - fairly simple generated code, erring on the side of duplicate code over nicely refactored code - supporting as much of OpenAPI 3.x as is possible, alongside Go's type system is one part of a wider ecosystem, which can be found described in further detail in the oapi-codegen organisation on GitHub. ⚠️ This README may be for the latest development version, which may contain unreleased changes. Please ensure you're looking at the README for the latest release version. Action Required: The repository for this project has changed As announced in May 2024, we have moved the project from the deepmap organization to our own organization, and you will need to update your import paths to pull updates past this point. You need to do a recursive search/replace from to . > !IMPORTANT > moved to its new home with the version tag . If you are using or below, please install like so: If you are using or above, please install like so, using the new module import path: Install For Go 1.24+ It is recommended to follow the support available from Go 1.24+ for managing the dependency of alongside your core application. To do this, you run : From there, each invocation of would be used like so: Prior to Go 1.24 It is recommended to follow the pattern for managing the dependency of alongside your core application. This would give you a : Then, each invocation of would be used like so: Alternatively, you can install it as a binary with: Which then means you can invoke it like so: Note that you can also move your into its own sub-module to reduce the impact on your top-level . Pinning to commits While the project does not yet have a defined release cadence, there may be cases where you want to pull in yet-unreleased changes to your codebase. Therefore, you may want to pin your dependency on to a given commit hash, rather than a tag. This is officially recommended for consumers of , who want features/bug fixes that haven't yet been released. We aim to keep the default branch ready-to-release so you should be able to safely pin. To do so, you can run: This will then make a change such as: Usage is largely configured using a YAML configuration file, to simplify the number of flags that users need to remember, and to make reading the command less daunting. For full details of what is supported, it's worth checking out the GoDoc for . We also have a JSON Schema that can be used by IDEs/editors with the Language Server Protocol LSP to perform intelligent suggestions, i.e.: Backwards compatibility Although we strive to retain backwards compatibility - as a project that's using a stable API per SemVer - there are sometimes opportunities we must take to fix a bug that could cause a breaking change for people relying upon the behaviour. In this case, we will expose a compatibility option to restore old behaviour. Features At a high level, supports: - Generating server-side boilerplate for a number of servers docs - Generating client API boilerplate docs - Generating the types docs - Splitting large OpenAPI specs across multiple packagesdocs - This is also known as "Import Mapping" or "external references" across our documentation / discussion in GitHub issues What does it look like? Below we can see a trimmed down example taken from the OpenAPI Petstore example: Then, in your own code, you implement the underlying logic for the implementation: As we can see, simplifies some of the boilerplate by taking parameters out of the request and instead allows us to focus on the implementation. You'll note that there's still a bit more marshaling of request/response data, which is further reduced by using the Strict server functionality. <a name="what-does-it-look-like-strict"></a> When using the strict server, you'll have the following generated code: Then, in your own code, you implement the underlying logic for the implementation: We can see that this provides the best means to focus on the implementation of the business logic within the endpoint, rather than unmarshalling types to and from JSON, or wrangling cookies or headers. Key design decisions - Produce an interface that can be satisfied by your implementation, with reduced boilerplate - Bulk processing and parsing of OpenAPI document in Go - Resulting output is using Go's s, which are user-overridable - Attempts to produce Idiomatic Go - Single-file output - Support multiple OpenAPI files by having a package-per-OpenAPI file - Support of OpenAPI 3.0 - OpenAPI 3.1 support is awaiting upstream support - Note that this does not include OpenAPI 2.0 aka Swagger - Extract parameters from requests, to reduce work required by your implementation - Implicit are ignored by default more details - Prune unused types by default Generating server-side boilerplate shines by making it fairly straightforward note that this is a purposeful choice of wording here - we want to avoid words like "easy" to generate the server-side boilerplate for a backend API. Below you can find the supported servers, and more information about how to implement a server using them. To provide you a fully Test Driven Development style test harness to confirm you are following the specification, you could use a tool such as openapi.tanna.dev/go/validator, or craft your own. Supported Servers Right now, we support the following servers, and are supportive of adding new servers, too! <table> <tr> <th> Server </th> <th> <code>generate</code> flag to enable code generation </th> <th> Example usage </th> </tr> <tr> <td> Chi </td> <td> <code>chi-server</code> </td> <td> For a Chi server, you will want a configuration file such as: To implement this, check out the Chi docs. </td> </tr> <tr> <td> Echo </td> <td> <code>echo-server</code> </td> <td> For an Echo server, you will want a configuration file such as: To implement this, check out the Echo docs. </td> </tr> <tr> <td> Fiber </td> <td> <code>fiber-server</code> </td> <td> For a Fiber server, you will want a configuration file such as: To implement this, check out the Fiber docs. </td> </tr> <tr> <td> Gin </td> <td> <code>gin-server</code> </td> <td> For a Gin server, you will want a configuration file such as: To implement this, check out the Gin docs. </td> </tr> <tr> <td> gorilla/mux </td> <td> <code>gorilla-server</code> </td> <td> For a gorilla/mux server, you will want a configuration file such as: To implement this, check out the gorilla/mux docs. </td> </tr> <tr> <td> Iris </td> <td> <code>iris-server</code> </td> <td> For a Iris server, you will want a configuration file such as: To implement this, check out the Iris docs. </td> </tr> <tr> <td> 1.22+ </td> <td> <code>std-http-server</code> </td> <td> To use purely for Go 1.22+, you will want a configuration file such as: To implement this, check out the Go 1.22+ docs. </td> </tr> </table> Go 1.22+ <a name="impl-stdhttp"></a> As of Go 1.22, enhancements have been made to the routing of the package in the standard library, which makes it a great starting point for implementing a server with, before needing to reach for another router or a full framework. For instance, let's take this straightforward specification: This then generates code such as: To implement this HTTP server, we need to write the following code in our examples/minimal-server/stdhttp/api/impl.go: Now we've got our implementation, we can then write the following code to wire it up and get a running server: > !NOTE > This doesn't include validation of incoming requests. > !NOTE > If you feel like you've done everything right, but are still receiving errors, make sure that you've got the directive in your updated to: </details> Chi <a name="impl-chi"></a> For instance, let's take this straightforward specification: This then generates code such as: To implement this HTTP server, we need to write the following code in our examples/minimal-server/chi/api/impl.go: Now we've got our implementation, we can then write the following code to wire it up and get a running server: > !NOTE > This doesn't include validation of incoming requests. gorilla/mux <a name="impl-gorillamux"></a> For instance, let's take this straightforward specification: This then generates code such as: To implement this HTTP server, we need to write the following code in our examples/minimal-server/gorillamux/api/impl.go: Now we've got our implementation, we can then write the following code to wire it up and get a running server: > !NOTE > This doesn't include validation of incoming requests. Echo server <a name="impl-echo"></a> For instance, let's take this straightforward specification: This then generates code such as: To implement this HTTP server, we need to write the following code in our examples/minimal-server/echo/api/impl.go: Now we've got our implementation, we can then write the following code to wire it up and get a running server: > !NOTE > This doesn't include validation of incoming requests. Fiber server <a name="impl-fiber"></a> For instance, let's take this straightforward specification: This then generates code such as: To implement this HTTP server, we need to write the following code in our examples/minimal-server/fiber/api/impl.go: Now we've got our implementation, we can then write the following code to wire it up and get a running server: > !NOTE > This doesn't include validation of incoming requests. Gin server <a name="impl-gin"></a> For instance, let's take this straightforward specification: This then generates code such as: To implement this HTTP server, we need to write the following code in our examples/minimal-server/gorillamux/api/impl.go: Now we've got our implementation, we can then write the following code to wire it up and get a running server: > !NOTE > This doesn't include validation of incoming requests. Iris server <a name="impl-iris"></a> For instance, let's take this straightforward specification: This then generates code such as: To implement this HTTP server, we need to write the following code in our examples/minimal-server/gorillamux/api/impl.go: Now we've got our implementation, we can then write the following code to wire it up and get a running server: > !NOTE > This doesn't include validation of incoming requests. Strict server also supports generating a server that is much more strict with the contract that the implementer requires, and takes inspiration from server-side code generation for RPC servers. This takes the boilerplate reduction from the non-strict servers and adds additional boilerplate reduction, allowing you to make the following changes to your function signatures: This is the highest level of strictness that supports right now, and it's a good idea to start with this if you want the most guardrails to simplify developing your APIs. The strict server has support for: - multiple request/response media types and status codes on a given operation - first-class support for and requests - returning an HTTP 500 Internal Server Error, when an is returned from a function - automagic unmarshalling of request/responses, and setting and HTTP status codes on responses - binding request values to a struct, a or providing a You can see a little more detail of the generated code in the "What does it look like" section. > !NOTE > To configure the strict server generation, you must specify another server to be generated. For instance: > !NOTE > This doesn't include validation of incoming requests. Generating API clients As well as generating the server-side boilerplate, can also generate API clients. This aims to be an API client that can be used to interact with the methods of the API, and is perfectly suited for production usage. However, if you were looking for a slightly more SDK-style approach, or a mix of generated tests and/or documentation, this API client may not be for you, and you may want to look at alternate tooling. For instance, given an : And a : And a : This would then generate: With this generated client, it is then possible to construct and utilise the client, for instance: With Server URLs An OpenAPI specification makes it possible to denote Servers that a client can interact with, such as: It is possible to opt-in to the generation of these Server URLs with the following configuration: This will then generate the following boilerplate: Notice that for URLs that are not templated, a simple definition is created. However, for more complex URLs that defined in them, we generate the types and any values or values, and instead use a function to create the URL. For a complete example see examples/generate/serverurls. Duplicate types generated for clients's response object types When generating the types for interacting with the generated client, will use the and add on a or suffix. However, this can clash if you have named your component schemas in a similar way. For instance: If you were to generate with this configuration: This would then result in failures: To fix this, use the Output Option: This will then rename the generated types from the default to use the new suffix: There is no currently planned work to change this behaviour. Generating API models If you're looking to only generate the models for interacting with a remote service, for instance if you need to hand-roll the API client for whatever reason, you can do this as-is. > !TIP > Try to define as much as possible within the object, as will generate all the types here. > > Although we can generate some types based on inline definitions in i.e. a path's response type, it isn't always possible to do this, or if it is generated, can be a little awkward to work with as it may be defined as an anonymous struct. For instance, given an : And a : And a : This would then generate: If you wish to also generate the type, you would need the following : For a complete example see examples/only-models. Splitting large OpenAPI specs across multiple packages aka "Import Mapping" or "external references" <a name=import-mapping></a> When you've got a large OpenAPI specification, you may find it useful to split the contents of the spec across multiple files, using external references, such as: This is supported by , through the ability to perform "Import Mapping". For instance, let's say that we have a large API, which has a user-facing API and an admin API, both of which use a common set of API models. In this case, we may have an Admin API that looks like: This references the common spec: So how do we get to generate our code? Using a single package with multiple OpenAPI specs <a name=import-mapping-self></a> > !TIP > Since v2.4.0, it is now possible to split large OpenAPI specifications into the same Go package, using the "self" mapping denoted by a when using Import Mapping. > > This is an improvement on the previous model, which would require splitting files across multiple packages. > !NOTE > You still need to have multiple s, and any other configuration files. To get 's single-package support working, we need multiple calls to , one call per OpenAPI spec file: This therefore means that we need multiple configuration files, such as : And then our : From here, will generate multiple Go files, all within the same package, which can be used to break down your large OpenAPI specifications, and generate only the subsets of code needed for each part of the spec. Check out the import-mapping/samepackage example for the full code. Using multiple packages, with one OpenAPI spec per package To get 's multi-package support working, we need to set up our directory structure: We could start with our configuration file for our admin API spec: If we were to run , this will fail with the following error This is because requires the : This will then generate the following code: If you don't want to do this, an alternate option is to use a single package, with multiple OpenAPI spec files for that given package or to bundle your multiple OpenAPI files into a single spec. Check out the import-mapping/multiplepackages example for the full code. Modifying the input OpenAPI Specification with OpenAPI Overlay Prior to v2.4.0, users wishing to override specific configuration, for instance taking advantage of extensions such as would need to modify the OpenAPI specification they are using. In a lot of cases, this OpenAPI specification would be produced by a different team to the consumers or even a different company and so asking them to make changes like this were unreasonable. This would lead to the API consumers needing to vendor the specification from the producer which is our recommendation anyway and then make any number of local changes to the specification to make it generate code that looks reasonable. However, in the case that a consumer would update their specification, they would likely end up with a number of merge conflicts. Now, as of v2.4.0, it is now possible to make changes to the input OpenAPI specification without needing to modify it directly. This takes advantage of the OpenAPI Overlay specification, which is a stable specification. > !CAUTION > Beware! Here may be dragons. > > The Overlay specification requires the use of JSON Path, which some users may find difficult to write and/or maintain. > > We still heavily recommend using Overlay functionality, but would like users to be aware of this. > > There is a proposed modification to the specification which would relax the need for JSON Path as the targeting mechanism. For instance, let's say that we have the following OpenAPI specification, which provides insight into an internal endpoint that we should not be generating any code for denoted by : If we were to run with out-of-the-box functionality, this would then lead to the DELETE endpoint being generated, which we don't want. Instead, we can define the following : And our configuration file for : This then completely removes the DELETE endpoint before we even start to parse the specification in , so it's as if your specification was provided without that endpoint. Additionally, we can override other pieces of metadata, such as the description for operations. Check out the overlay example for the full code, and some more complex examples. Generating Nullable types It's possible that you want to be able to determine whether a field isn't sent, is sent as or has a value. For instance, if you had the following OpenAPI property: The default behaviour in is to generate: However, you lose the ability to understand the three cases, as there's no way to distinguish two of the types from each other: - is this field not sent? Can be checked with - is this field ? Can be checked with - does this field have a value? As of v2.1.0 it is now possible to represent this with the type from our new library, oapi-codegen/nullable. If you configure your generator's Output Options to opt-in to this behaviour, as so: You will now receive the following output: OpenAPI extensions As well as the core OpenAPI support, we also support the following OpenAPI extensions, as denoted by the OpenAPI Specification Extensions. The following extensions are supported: <table> <tr> <th> Extension </th> <th> Description </th> </tr> <tr> <td> <br> </td> <td> Override the generated type definition and optionally, add an import from another package </td> </tr> <tr> <td> </td> <td> Do not add a pointer type for optional fields in structs </td> </tr> <tr> <td> </td> <td> Override the generated name of a field or a type </td> </tr> <tr> <td> </td> <td> Override the generated name of a type </td> </tr> <tr> <td> </td> <td> Force the presence of the JSON tag on a field </td> </tr> <tr> <td> </td> <td> Force the presence of the JSON tag on a field </td> </tr> <tr> <td> </td> <td> When unmarshaling JSON, ignore fields </td> </tr> <tr> <td> </td> <td> Generate arbitrary struct tags to fields </td> </tr> <tr> <td> / </td> <td> Override generated variable names for enum constants </td> </tr> <tr> <td> </td> <td> Add a GoDoc deprecation warning to a type </td> </tr> <tr> <td> </td> <td> Explicitly order struct fields </td> </tr> <tr> <td> </td> <td> Only honour the when generating field names </td> </tr> </table> / - override the generated type definition and optionally, add an import from another package Using the and optionally, when you need to import another package allows overriding the type that determined the generated type should be. We can see this at play with the following schemas: From here, we now get two different models: You can see this in more detail in the example code. - do not add a pointer type for optional fields in structs <a name="ext-x-go-type-skip-optional-pointer"></a> > !TIP > If you prefer this behaviour, and prefer to not have to annotate your whole OpenAPI spec for this behaviour, you can use to default this behaviour for all fields. > > It is then possible to override this on a per-type/per-field basis where necessary. By default, will generate a pointer for optional fields. Using the extension allows omitting that pointer. We can see this at play with the following schemas: From here, we now get two different models: You can see this in more detail in the example code. - override the generated name of a field or a type By default, will attempt to generate the name of fields and types in as best a way it can. However, sometimes, the name doesn't quite fit what your codebase standards are, or the intent of the field, so you can override it with . We can see this at play with the following schemas: From here, we now get two different models: You can see this in more detail in the example code. - Override the generated name of a type > !NOTE > Notice that this is subtly different to the , which also applies to fields within s. By default, will attempt to generate the name of types in as best a way it can. However, sometimes, the name doesn't quite fit what your codebase standards are, or the intent of the field, so you can override it with . We can see this at play with the following schemas: From here, we now get two different models and a type alias: You can see this in more detail in the example code. - force the presence of the JSON tag on a field In a case that you may want to add the JSON struct tag to types that don't have one generated by default - for instance a required field - you can use the extension. We can see this at play with the following schemas: From here, we now get two different models: You can see this in more detail in the example code. - force the presence of the JSON tag on a field > !NOTE > was added in Go 1.24. If you're not using Go 1.24 in your project, this won't work. In a case that you may want to add the JSON struct tag to types, you can use the extension. We can see this at play with the following schemas: From here, we now get two different models: You can see this in more detail in the example code. - when unmarshaling JSON, ignore fields By default, will generate struct tags for all fields in a struct, so JSON unmarshaling works. However, sometimes, you want to omit fields, which can be done with the extension. We can see this at play with the following schemas: From here, we now get two different models: Notice that the is still generated in full, but the type will then be ignored with JSON marshalling. You can see this in more detail in the example code. - generate arbitrary struct tags to fields If you're making use of a field's struct tags to i.e. apply validation, decide whether something should be logged, etc, you can use to set additional tags for your generated types. We can see this at play with the following schemas: From here, we now get two different models: You can see this in more detail in the example code. / - override generated variable names for enum constants When consuming an enum value from an external system, the name may not produce a nice variable name. Using the extension allows overriding the name of the generated variable names. We can see this at play with the following schemas: From here, we now get two different forms of the same enum definition. You can see this in more detail in the example code. - add a GoDoc deprecation warning to a type When an OpenAPI type is deprecated, a deprecation warning can be added in the GoDoc using . We can see this at play with the following schemas: From here, we now get two different forms of the same enum definition. Notice that because we've not set to the field, it doesn't generate a deprecation warning. You can see this in more detail in the example code. - explicitly order struct fields Whether you like certain fields being ordered before others, or you want to perform more efficient packing of your structs, the extension is here for you. Note that is 1-indexed - is not a valid value. We can see this at play with the following schemas: From here, we now get two different forms of the same type definition. You can see this in more detail in the example code. - only honour the when generating field names > !WARNING > Using this option may lead to cases where 's rewriting of field names to prevent clashes with other types, or to prevent including characters that may not be valid Go field names. In some cases, you may not want use the inbuilt options for converting an OpenAPI field name to a Go field name, such as the , and instead trust the name that you've defined for the type better. In this case, you can use to enforce this, alongside specifying the compatibility option. This allows you to take a spec such as: And we'll generate: You can see this in more detail in the example code. Request/response validation middleware The generated code that produces has some validation for some incoming data, such as checking for required headers, and when using the strict server you get some more validation around the correct usage of the response types. However, this leaves a lot of validation that needs to be done, which can be tedious to hand-write this logic, especially for large or complex OpenAPI specifications. To simplify this, we use a middleware, which provides the request validation. The middleware you want to use depends on the server you're using: <table> <tr> <th> Server </th> <th> Middleware library </th> </tr> <tr> <td> Chi </td> <td> nethttp-middleware </td> </tr> <tr> <td> Echo </td> <td> echo-middleware </td> </tr> <tr> <td> Fiber </td> <td> fiber-middleware </td> </tr> <tr> <td> Gin </td> <td> gin-middleware </td> </tr> <tr> <td> gorilla/mux </td> <td> nethttp-middleware </td> </tr> <tr> <td> Iris </td> <td> iris-middleware </td> </tr> <tr> <td> 1.22+ </td> <td> nethttp-middleware </td> </tr> <tr> <td> Any other server which conforms to </td> <td> nethttp-middleware </td> </tr> </table> > !NOTE > It is not currently possible to validate the HTTP response with a middleware. > !NOTE > We're also exploring the use of libopenapi-validator for request/response validation middleware Implementing security If you're using a specification with Security Schemes and Security Requirements, you'll want to authenticate and authorize requests. On the server > !NOTE > Out-of-the-box, the server-side code generated by does not provide security validation. > > To perform authentication, you will need to use the validation middleware. > > In the future, we plan to implement server-side validation in the generated code To see how this can work, check out the authenticated API example. On the client With a generated client, you'll want to use the client's generated function to pass in a given request editor . For instance: Notice that we're using a pre-built provider from the package, which has some inbuilt support for other types of authentication, too. Custom code generation It is possible to extend the inbuilt code generation from using Go's s. You can specify, through your configuration file, the setting to override the inbuilt templates and use a user-defined template. > !NOTE > Filenames given to the configuration must exactly match the filename that is looking for Local paths Within your configuration file, you can specify relative or absolute paths to a file to reference for the template, such as: > !WARNING > We do not interpolate or or other environment variables in paths given HTTPS paths It is also possible to use HTTPS URLs. > !WARNING > Although possible, this does lead to executions not necessarily being reproducible. It's recommended to vendor copy the OpenAPI spec into your codebase and reference it locally > > See this blog post for an example of how to use GitHub Actions to manage the updates of files across repos > > This will be disabled by default but possible to turn back on via configuration in the future To use it, you can use the following configuration: > !WARNING > If using URLs that pull locations from a Git repo, such as , it is strongly encouraged to use a tag or a raw commit hash instead of a branch like . Tracking a branch can lead to unexpected API drift, and loss of the ability to reproduce a build. Inline template It's also possible to set the templates inline in the configuration file: Using the Go package Alternatively, you are able to use the underlying code generation as a package, which will be documented in the future. Additional Properties OpenAPI Schemas implicitly accept , meaning that any fields provided, but not explicitly defined via properties on the schema are accepted as input, and propagated. When unspecified, OpenAPI defines that the field is assumed to be . For simplicity, and to remove a fair bit of duplication and boilerplate, decides to ignore the implicit , and instead requires you to specify the key to generate the boilerplate. > !NOTE > In the future this will be possible to disable this functionality, and honour the implicit Below you can see some examples of how affects the generated code. Implicit / no set Will generate: Explicit Will generate: <details> <summary>Boilerplate</summary> </details> as s Will generate: <details> <summary>Boilerplate</summary> </details> with an object Will generate: <details> <summary>Boilerplate</summary> </details> Globally skipping the "optional pointer" One of the key things does is to use an "optional pointer", following idiomatic Go practices, to indicate that a field/type is optional. This can be tuned on a per-field basis, using the extension, but it can be a bit repetitive, or can be more complex when using an OpenAPI Overlay. As of v2.5.0, this can be tuned in two specific ways, via the following : - : a global default that you do not want the "optional pointer" generated. Optional fields will not have an "optional pointer", and will have an JSON tag - : when used in conjunction with , any optional fields are generated with an JSON tag. Requires Go 1.24+ In both cases, there is control on a per-field level to set or to undo these to fields. For example, when combining both options: When we have the following spec: We then generate the following Go code: You can see this in more detail in the example code for and example code for Changing the names of generated types As of v2.2.0, it is now possible to use the configuration's to define the logic for how to convert an OpenAPI name i.e. an Operation ID or a Schema name and construct a Go type name. <details> <summary>Example, using default configuration</summary> By default, will perform camel-case conversion, so for a spec such as: This will produce: </details> <details> <summary>Example, using <code>ToCamelCaseWithInitialisms</code></summary> By default, will perform camel-case conversion, so for a spec such as: This will produce: </details> For more details of what the resulting code looks like, check out the test cases. Examples The examples directory contains some additional cases which are useful examples for how to use , including how you'd take the Petstore API and implement it with . You could also find some cases of how the project can be used by checking out our internal test cases which are real-world usages that make up our regression tests. Blog posts We love reading posts by the community about how to use the project. Here are a few we've found around the Web: - Building a Go RESTful API with design-first OpenAPI contracts - A Practical Guide to Using oapi-codegen in Golang API Development with the Fiber Framework - Generating Go server code from OpenAPI 3 definitions - Go Client Code Generation from Swagger and OpenAPI - Go oapi-codegen + request validation - Streamlining Go + Chi Development: Generating Code from an OpenAPI Spec Got one to add? Please raise a PR! Frequently Asked Questions FAQs Does support OpenAPI 3.1? No, we don't currently. OpenAPI 3.1 support is awaiting upstream support. In the meantime, you could follow steps from this blog post to use OpenAPI Overlay to "downgrade" the OpenAPI 3.1 spec to OpenAPI 3.0. How does handle , and ? supports , and for generated code. For instance, through the following OpenAPI spec: This results in the following types: <details> <summary>Base types</summary> </details> <details> <summary><code>allOf</code></summary> </details> <details> <summary><code>anyOf</code></summary> </details> <details> <summary><code>oneOf</code></summary> </details> For more info, check out the example code. How can I ignore parts of the spec I don't care about? By default, will generate everything from the specification. If you'd like to reduce what's generated, you can use one of a few options in the configuration file to tune the generation of the resulting output: Check the docs for more details of usage. Should I commit the generated code? We recommend doing so, yes, for the following reasons: - It means it's easier to view the impact of a change - be it due to an upgrade of , or a change to your spec - and has helped catch possibly breaking changes in the past more easily - It then allows your codebase to be consumed as a library, as all the files are committed This means you'll need to have your CI/CD pipeline validate that generated files are all up-to-date, but that's a fairly straightforward piece of work. Should I lint the generated code? We really ask that you don't. Although it intends to be idiomatic Go code, it's not expected to pass all the various linting rules that your project may apply. > !NOTE > We will, on occasion, improve the generated code to fix some linting warnings, such as those from , but this should not be an expected change. I've just updated my version of , and now I can't build my code 😠 The kin-openapi project - which we 💜 for providing a great library and set of tooling for interacting with OpenAPI - is a pre-v1 release, which means that they're within their rights to push breaking changes. This may lead to breakage in your consuming code, and if so, sorry that's happened! We'll be aware of the issue, and will work to update both the core and the middlewares accordingly. Contributors We're very appreciative of the many contributors over the years and the ongoing use of the project 💜 <a href="https://github.com/oapi-codegen/oapi-codegen/graphs/contributors"> <img src="https://contrib.rocks/image?repo=oapi-codegen/oapi-codegen" /> </a> Sponsors For the most part, is maintained in two busy peoples' free time. As noted in Creating a more sustainable model for in the future, we're looking to make this a more sustainable project in the future. Please consider sponsoring us through GitHub Sponsors either on the organisation or directly for Jamie, which helps work towards us being able to maintain the project long term. See this blog post from Tidelift for more details on how to talk to your company about sponsoring maintainers of Open Source projects you depend on. We are currently sponsored for 4 hours of work a month by Elastic: <p align="center"> <a href="https://elastic.co?utmsource=oapi-codegen+repo&utmmedium=github+sponsorship"> <picture> <source media="prefers-color-scheme: light" srcset=".github/sponsors/elastic-light.svg"> <source media="prefers-color-scheme: dark" srcset=".github/sponsors/elastic-dark.svg"> <img alt="Elastic logo" src=".github/sponsors/elastic-dark.svg" height="100px"> </picture> </a> </p> In addition, we are also generously sponsored by the following folks, each of whom provide sponsorship for 1 hour of work a month: <p align="center"> <a href="https://www.devzero.io/lp/dev-environment?utmcampaign=github&utmsource=oapi-codegen%20repo&utmmedium=github%20sponsorship"> <picture> <source media="prefers-color-scheme: light" srcset=".github/sponsors/devzero-light.svg"> <source media="prefers-color-scheme: dark" srcset=".github/sponsors/devzero-dark.svg"> <img alt="DevZero logo" src=".github/sponsors/devzero-dark.svg" height="100px"> </picture> </a> </p> <p align="center"> <a href="https://sandbox.speakeasy.com/?s=iQ5hEdrjLCii&utmsource=oapi-codegen+repo&utmmedium=github+sponsorship"> <picture> <source media="prefers-color-scheme: light" srcset=".github/sponsors/speakeasy-light.svg"> <source media="prefers-color-scheme: dark" srcset=".github/sponsors/speakeasy-dark.svg"> <img alt="Speakeasy logo" src=".github/sponsors/speakeasy-dark.svg" height="60px"> </picture> </a> </p> <p align="center"> <a href="https://cybozu.co.jp/?utmsource=oapi-codegen+repo&utmmedium=github+sponsorship"> <img alt="Cybozu logo" src=".github/sponsors/cybozu.svg" height="100px"> </a> </p> <p align="center"> <a href="https://livepeer.org/?utmsource=oapi-codegen+repo&utmmedium=github+sponsorship"> <picture> <source media="prefers-color-scheme: light" srcset=".github/sponsors/livepeer-light.svg"> <source media="prefers-color-scheme: dark" srcset=".github/sponsors/livepeer-dark.svg"> <img alt="Livepeer logo" src=".github/sponsors/livepeer-dark.svg" height="50px"> </picture> </a> </p> Note that the order of appearance the order in which sponsorship was received